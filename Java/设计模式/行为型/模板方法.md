# 模板方法

## 定义

​	模板模式，英文是 Template Method Design Pattern，模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。

​	模板模式有两大作用：**复用和扩展**。其中，复用指的是，所有的子类可以复用父类中提供的模板方法的代码。扩展指的是，框架通过模板模式提供功能扩展点，让框架用户可以在不修改框架源码的情况下，基于扩展点定制化框架的功能。 

------

## 经典实现

​	在模板模式经典的实现中，模板方法定义为 **final**，可以避免被子类重写。需要子类重写的方法定义为 **abstract**，可以强迫子类去实现。不过，在实际项目开发中，模板模式的实现比较灵活，以上两点都不是必须的。 

- 模板方法定义为final，避免非复写。**❤这个容易被忘记**
- 需要被复写的方法定义为abstract，强迫子类实现
- 如果是非必选流程，可以提供默认实现，或者抛出异常。
- 父类的流程如果取决于子类，提供Hook方法

------

## 模板vs回调

- **同步回调**：B类的入参是一个CallBack，执行完后会进行调用，看起来更像模板模式 

  ```java
  
  public interface ICallback {
    void methodToCallback();
  }
  
  public class BClass {
    public void process(ICallback callback) {
      //...
      callback.methodToCallback();
      //...
    }
  }
  
  public class AClass {
    public static void main(String[] args) {
      BClass b = new BClass();
      b.process(new ICallback() { //回调对象
        @Override
        public void methodToCallback() {
          System.out.println("Call back me.");
        }
      });
    }
  }
  ```

  

-  **异步回调** ：FutureListener，非阻塞的支付回调等，看起来更像观察者模式。 

### 对比差异（回调>模板）：

回调基于组合关系来实现，把一个对象传递给另一个对象，是一种对象之间的关系；

模板模式基于继承关系来实现，子类重写父类的抽象方法，是一种类之间的关系。

 在代码实现上，**回调相对于模板模式会更加灵活**，主要体现在下面几点。 

-  像 Java 这种只支持单继承的语言，基于模板模式编写的子类，已经继承了一个父类，不再具有继承的能力。 
-  回调可以使用匿名类来创建回调对象，可以不用事先定义类；而模板模式针对不同的实现都要定义不同的子类。 
-  如果某个类中定义了多个模板方法，每个方法都有对应的抽象方法，那即便我们只用到其中的一个模板方法，子类也必须实现所有的抽象方法。而回调就更加灵活，我们只需要往用到的模板方法中注入回调对象即可。 

### 实际上，个人角度来看，这两者没有太大的联系 ❤

- 模板方法是静态的，提前定义好的类，偏重量级，适合复杂，固定的流程
- 回调方法是动态的，可以实现匿名类，偏轻量级，适合简单的，非必需的流程
- **模板方法调用是自己的方法，回调方法调用的入参的方法，这个本质区别决定了模板方法适合于自己的代码流程，而回调方法适合于提供api**

