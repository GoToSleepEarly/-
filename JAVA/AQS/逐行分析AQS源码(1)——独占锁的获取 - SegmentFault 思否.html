<!DOCTYPE html>
<!-- saved from url=(0043)https://segmentfault.com/a/1190000015739343 -->
<html lang="zh-CN" data-react-helmet="lang"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否</title>
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
    <meta httpequiv="X-UA-Compatible" content="IE=edge, chrome=1">
    <meta name="renderer" content="webkit">
    <meta name="alexaVerifyID" content="LkzCRJ7rPEUwt6fVey2vhxiw1vQ">
    <meta name="apple-itunes-app" content="app-id=958101793, app-argument=">
    <meta property="qc:admins" content="15317273575564615446375">
    <meta name="msapplication-TileColor" content="#009a61">
    <meta name="baidu_union_verify" content="bcf7fd80dca60d53d46d5b46e1b990ca">
    <meta name="sogou_site_verification" content="MKVKCoIjwL">
    <meta name="360-site-verification" content="737314c9bf48873a1a0a22295203d9d1">
    <meta rel="apple-touch-icon" href="https://cdn.segmentfault.com/r-18a99036/touch-icon.png">
    <meta name="msapplication-square150x150logo" content="https://cdn.segmentfault.com/r-18a99036/touch-icon.png">
    <link rel="shortcut icon" type="image/x-icon" href="https://cdn.segmentfault.com/r-18a99036/favicon.ico">
    <link rel="search" type="application/opensearchdescription+xml" href="https://segmentfault.com/opensearch.xml" title="SegmentFault">
    <link rel="alternate" type="application/atom+xml" href="https://segmentfault.com/feeds/questions" title="SegmentFault 最新问题">
    <link rel="alternate" type="application/atom+xml" href="https://segmentfault.com/feeds/blogs" title="SegmentFault 最新文章">
    <link rel="stylesheet" href="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/umi.css">
    <script src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/osd.js.下载"></script><script src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/f(4).txt"></script><script src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/f(5).txt" id="google_shimpl"></script><script async="" defer="" src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/f(6).txt"></script><script async="" defer="" src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/fl.js.下载"></script><script async="" defer="" src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/spc.php"></script><script type="text/javascript" async="" src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/analytics.js.下载"></script><script async="" defer="" src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/spcjs.php"></script><script src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/hm.js.下载"></script><script>
      window.routerBase = "/";
    </script>
    <script>
      window.publicPath =
        window.resourceBaseUrl || "https://cdn.segmentfault.com/r-18a99036/";
    </script>
    <script>
      //! umi version: 3.3.7
    </script>
    <script>
      var _hmt = _hmt || [];
    </script>
    <script>
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?e23800c454aa573c0ccb16b52665ac26";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  <meta data-react-helmet="true" name="keywords" content="java,java并发"><meta data-react-helmet="true" name="description" content="AQS（AbstractQueuedSynchronizer）是JAVA中众多锁以及并发工具的基础，其底层采用乐观锁，大量使用了CAS操作， 并且在冲突时，采用自旋方式重试，以实现轻量级和高效地获取锁。"><meta data-react-helmet="true" name="userId" value="" id="SFUserId"><meta data-react-helmet="true" name="userRank" value="" id="SFUserRank"><meta data-react-helmet="true" name="twitter:card" content="summary"><meta data-react-helmet="true" name="twitter:site" content="@segment_fault"><meta data-react-helmet="true" name="twitter:creator" content="@segmentfault"><meta data-react-helmet="true" name="twitter:title" content="逐行分析AQS源码(1)——独占锁的获取"><meta data-react-helmet="true" name="og:type" content="article"><meta data-react-helmet="true" name="og:title" content="逐行分析AQS源码(1)——独占锁的获取"><meta data-react-helmet="true" name="msvalidate.01" content="2C018C53297C8388F3E7052F5E9CA6AF"><link rel="stylesheet" href="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/layouts__index_p__Live__Add_p__Video__Add_p__Write.chunk.css">
<link rel="stylesheet" href="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/layouts__index.chunk.css">
<link rel="stylesheet" href="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/p__ArticleDetail.chunk.css">
<script src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/js" async=""></script><style>#__vconsole {
  --VC-BG-0: #ededed;
  --VC-BG-1: #f7f7f7;
  --VC-BG-2: #fff;
  --VC-BG-3: #f7f7f7;
  --VC-BG-4: #4c4c4c;
  --VC-BG-5: #fff;
  --VC-FG-0: rgba(0, 0, 0, 0.9);
  --VC-FG-HALF: rgba(0, 0, 0, 0.9);
  --VC-FG-1: rgba(0, 0, 0, 0.5);
  --VC-FG-2: rgba(0, 0, 0, 0.3);
  --VC-FG-3: rgba(0, 0, 0, 0.1);
  --VC-RED: #fa5151;
  --VC-ORANGE: #fa9d3b;
  --VC-YELLOW: #ffc300;
  --VC-GREEN: #91d300;
  --VC-LIGHTGREEN: #95ec69;
  --VC-BRAND: #07c160;
  --VC-BLUE: #10aeff;
  --VC-INDIGO: #1485ee;
  --VC-PURPLE: #6467f0;
  --VC-LINK: #576b95;
  --VC-TEXTGREEN: #06ae56;
  --VC-FG: black;
  --VC-BG: white;
  --VC-BG-COLOR-ACTIVE: #ececec;
  --VC-WARN-BG: #fff3cc;
  --VC-WARN-BORDER: #ffe799;
  --VC-ERROR-BG: #fedcdc;
  --VC-ERROR-BORDER: #fdb9b9;
  --VC-DOM-TAG-NAME-COLOR: #881280;
  --VC-DOM-ATTRIBUTE-NAME-COLOR: #994500;
  --VC-DOM-ATTRIBUTE-VALUE-COLOR: #1a1aa6;
  --VC-CODE-KEY-FG: #881391;
  --VC-CODE-PRIVATE-KEY-FG: #cfa1d3;
  --VC-CODE-FUNC-FG: #0d22aa;
  --VC-CODE-NUMBER-FG: #1c00cf;
  --VC-CODE-STR-FG: #c41a16;
  --VC-CODE-NULL-FG: #808080;
  color: var(--VC-FG-0);
  font-size: 13px;
  font-family: Helvetica Neue, Helvetica, Arial, sans-serif;
  -webkit-user-select: auto;
  /* global */
  /* compoment */
}
#__vconsole .vc-max-height {
  max-height: 19.23076923em;
}
#__vconsole .vc-max-height-line {
  max-height: 3.38461538em;
}
#__vconsole .vc-min-height {
  min-height: 3.07692308em;
}
#__vconsole dd,
#__vconsole dl,
#__vconsole pre {
  margin: 0;
}
#__vconsole .vc-switch {
  display: block;
  position: fixed;
  right: 0.76923077em;
  bottom: 0.76923077em;
  color: #FFF;
  background-color: var(--VC-BRAND);
  line-height: 1;
  font-size: 1.07692308em;
  padding: 0.61538462em 1.23076923em;
  z-index: 10000;
  border-radius: 0.30769231em;
  box-shadow: 0 0 0.61538462em rgba(0, 0, 0, 0.4);
}
#__vconsole .vc-mask {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0);
  z-index: 10001;
  -webkit-transition: background 0.3s;
  transition: background 0.3s;
  -webkit-tap-highlight-color: transparent;
  overflow-y: scroll;
}
#__vconsole .vc-panel {
  display: none;
  position: fixed;
  min-height: 85%;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 10002;
  background-color: var(--VC-BG-0);
  -webkit-transition: -webkit-transform 0.3s;
  transition: -webkit-transform 0.3s;
  transition: transform 0.3s;
  transition: transform 0.3s, -webkit-transform 0.3s;
  -webkit-transform: translate(0, 100%);
  transform: translate(0, 100%);
}
#__vconsole .vc-tabbar {
  border-bottom: 1px solid var(--VC-FG-3);
  overflow-x: auto;
  height: 3em;
  width: auto;
  white-space: nowrap;
}
#__vconsole .vc-tabbar .vc-tab {
  display: inline-block;
  line-height: 3em;
  padding: 0 1.15384615em;
  border-right: 1px solid var(--VC-FG-3);
  text-decoration: none;
  color: var(--VC-FG-0);
  -webkit-tap-highlight-color: transparent;
  -webkit-touch-callout: none;
}
#__vconsole .vc-tabbar .vc-tab:active {
  background-color: rgba(0, 0, 0, 0.15);
}
#__vconsole .vc-tabbar .vc-tab.vc-actived {
  background-color: var(--VC-BG-1);
}
#__vconsole .vc-content {
  background-color: var(--VC-BG-2);
  overflow-x: hidden;
  overflow-y: auto;
  position: absolute;
  top: 3.07692308em;
  left: 0;
  right: 0;
  bottom: 3.07692308em;
  -webkit-overflow-scrolling: touch;
  margin-bottom: constant(safe-area-inset-bottom);
  margin-bottom: env(safe-area-inset-bottom);
}
#__vconsole .vc-content.vc-has-topbar {
  top: 5.46153846em;
}
#__vconsole .vc-topbar {
  background-color: var(--VC-BG-1);
  display: -webkit-box;
  display: -webkit-flex;
  display: -moz-box;
  display: -ms-flexbox;
  display: flex;
  -webkit-box-orient: horizontal;
  -webkit-box-direction: normal;
  -webkit-flex-direction: row;
  -moz-box-orient: horizontal;
  -moz-box-direction: normal;
  -ms-flex-direction: row;
  flex-direction: row;
  -webkit-flex-wrap: wrap;
  -ms-flex-wrap: wrap;
  flex-wrap: wrap;
  width: 100%;
}
#__vconsole .vc-topbar .vc-toptab {
  display: none;
  -webkit-box-flex: 1;
  -webkit-flex: 1;
  -moz-box-flex: 1;
  -ms-flex: 1;
  flex: 1;
  line-height: 2.30769231em;
  padding: 0 1.15384615em;
  border-bottom: 1px solid var(--VC-FG-3);
  text-decoration: none;
  text-align: center;
  color: var(--VC-FG-0);
  -webkit-tap-highlight-color: transparent;
  -webkit-touch-callout: none;
}
#__vconsole .vc-topbar .vc-toptab.vc-toggle {
  display: block;
}
#__vconsole .vc-topbar .vc-toptab:active {
  background-color: rgba(0, 0, 0, 0.15);
}
#__vconsole .vc-topbar .vc-toptab.vc-actived {
  border-bottom: 1px solid var(--VC-INDIGO);
}
#__vconsole .vc-logbox {
  display: none;
  position: relative;
  min-height: 100%;
}
#__vconsole .vc-logbox i {
  font-style: normal;
}
#__vconsole .vc-logbox .vc-log {
  padding-bottom: 6em;
  -webkit-tap-highlight-color: transparent;
}
#__vconsole .vc-logbox .vc-log:empty:before {
  content: "Empty";
  color: var(--VC-FG-1);
  position: absolute;
  top: 45%;
  left: 0;
  right: 0;
  bottom: 0;
  font-size: 1.15384615em;
  text-align: center;
}
#__vconsole .vc-logbox .vc-item {
  margin: 0;
  padding: 0.46153846em 0.61538462em;
  overflow: hidden;
  line-height: 1.3;
  border-bottom: 1px solid var(--VC-FG-3);
  word-break: break-word;
}
#__vconsole .vc-logbox .vc-item-info {
  color: var(--VC-PURPLE);
}
#__vconsole .vc-logbox .vc-item-debug {
  color: var(--VC-YELLOW);
}
#__vconsole .vc-logbox .vc-item-warn {
  color: var(--VC-ORANGE);
  border-color: var(--VC-WARN-BORDER);
  background-color: var(--VC-WARN-BG);
}
#__vconsole .vc-logbox .vc-item-error {
  color: var(--VC-RED);
  border-color: var(--VC-ERROR-BORDER);
  background-color: var(--VC-ERROR-BG);
}
#__vconsole .vc-logbox .vc-log.vc-log-partly .vc-item {
  display: none;
}
#__vconsole .vc-logbox .vc-log.vc-log-partly-log .vc-item-log,
#__vconsole .vc-logbox .vc-log.vc-log-partly-info .vc-item-info,
#__vconsole .vc-logbox .vc-log.vc-log-partly-warn .vc-item-warn,
#__vconsole .vc-logbox .vc-log.vc-log-partly-error .vc-item-error {
  display: block;
}
#__vconsole .vc-logbox .vc-item.hide {
  display: none;
}
#__vconsole .vc-logbox .vc-item .vc-item-content {
  margin-right: 4.61538462em;
  display: inline-block;
}
#__vconsole .vc-logbox .vc-item .vc-item-repeat {
  display: inline-block;
  margin-right: 0.30769231em;
  padding: 0 6.5px;
  color: #D7E0EF;
  background-color: #42597F;
  border-radius: 8.66666667px;
}
#__vconsole .vc-logbox .vc-item.vc-item-error .vc-item-repeat {
  color: #901818;
  background-color: var(--VC-RED);
}
#__vconsole .vc-logbox .vc-item.vc-item-warn .vc-item-repeat {
  color: #987D20;
  background-color: #F4BD02;
}
#__vconsole .vc-logbox .vc-item .vc-item-code {
  display: block;
  white-space: pre-wrap;
  overflow: auto;
  position: relative;
}
#__vconsole .vc-logbox .vc-item .vc-item-code.vc-item-code-input,
#__vconsole .vc-logbox .vc-item .vc-item-code.vc-item-code-output {
  padding-left: 0.92307692em;
}
#__vconsole .vc-logbox .vc-item .vc-item-code.vc-item-code-input:before,
#__vconsole .vc-logbox .vc-item .vc-item-code.vc-item-code-output:before {
  content: "›";
  position: absolute;
  top: -0.23076923em;
  left: 0;
  font-size: 1.23076923em;
  color: #6A5ACD;
}
#__vconsole .vc-logbox .vc-item .vc-item-code.vc-item-code-output:before {
  content: "‹";
}
#__vconsole .vc-logbox .vc-item .vc-fold {
  display: block;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
}
#__vconsole .vc-logbox .vc-item .vc-fold .vc-fold-outer {
  display: block;
  font-style: italic;
  padding-left: 0.76923077em;
  position: relative;
}
#__vconsole .vc-logbox .vc-item .vc-fold .vc-fold-outer:active {
  background-color: var(--VC-BG-COLOR-ACTIVE);
}
#__vconsole .vc-logbox .vc-item .vc-fold .vc-fold-outer:before {
  content: "";
  position: absolute;
  top: 0.30769231em;
  left: 0.15384615em;
  width: 0;
  height: 0;
  border: transparent solid 0.30769231em;
  border-left-color: var(--VC-FG-1);
}
#__vconsole .vc-logbox .vc-item .vc-fold .vc-fold-outer.vc-toggle:before {
  top: 0.46153846em;
  left: 0;
  border-top-color: var(--VC-FG-1);
  border-left-color: transparent;
}
#__vconsole .vc-logbox .vc-item .vc-fold .vc-fold-inner {
  display: none;
  margin-left: 0.76923077em;
}
#__vconsole .vc-logbox .vc-item .vc-fold .vc-fold-inner.vc-toggle {
  display: block;
}
#__vconsole .vc-logbox .vc-item .vc-fold .vc-fold-inner .vc-code-key {
  margin-left: 0.76923077em;
}
#__vconsole .vc-logbox .vc-item .vc-fold .vc-fold-outer .vc-code-key {
  margin-left: 0;
}
#__vconsole .vc-logbox .vc-code-key {
  color: var(--VC-CODE-KEY-FG);
}
#__vconsole .vc-logbox .vc-code-private-key {
  color: var(--VC-CODE-PRIVATE-KEY-FG);
}
#__vconsole .vc-logbox .vc-code-function {
  color: var(--VC-CODE-FUNC-FG);
  font-style: italic;
}
#__vconsole .vc-logbox .vc-code-number,
#__vconsole .vc-logbox .vc-code-boolean {
  color: var(--VC-CODE-NUMBER-FG);
}
#__vconsole .vc-logbox .vc-code-string {
  color: var(--VC-CODE-STR-FG);
}
#__vconsole .vc-logbox .vc-code-null,
#__vconsole .vc-logbox .vc-code-undefined {
  color: var(--VC-CODE-NULL-FG);
}
#__vconsole .vc-logbox .vc-cmd {
  position: absolute;
  height: 3.07692308em;
  left: 0;
  right: 0;
  bottom: 41px;
  border-top: 1px solid var(--VC-FG-3);
  display: block!important;
}
#__vconsole .vc-logbox .vc-cmd.vc-filter {
  bottom: 0;
}
#__vconsole .vc-logbox .vc-cmd .vc-cmd-input-wrap {
  display: block;
  height: 2.15384615em;
  margin-right: 3.07692308em;
  padding: 0.46153846em 0.61538462em;
}
#__vconsole .vc-logbox .vc-cmd .vc-cmd-input {
  width: 100%;
  border: none;
  resize: none;
  outline: none;
  padding: 0;
  font-size: 0.92307692em;
  background-color: transparent;
  color: var(--VC-FG-0);
}
#__vconsole .vc-logbox .vc-cmd .vc-cmd-input::-webkit-input-placeholder {
  line-height: 2.15384615em;
}
#__vconsole .vc-logbox .vc-cmd .vc-cmd-btn {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  width: 3.07692308em;
  border: none;
  background-color: var(--VC-BG-0);
  color: var(--VC-FG-0);
  outline: none;
  -webkit-touch-callout: none;
  font-size: 1em;
}
#__vconsole .vc-logbox .vc-cmd .vc-cmd-btn:active {
  background-color: rgba(0, 0, 0, 0.15);
}
#__vconsole .vc-logbox .vc-cmd .vc-cmd-prompted {
  position: fixed;
  width: 100%;
  background-color: var(--VC-BG-3);
  border: 1px solid var(--VC-FG-3);
  overflow-x: scroll;
  display: none;
}
#__vconsole .vc-logbox .vc-cmd .vc-cmd-prompted li {
  list-style: none;
  line-height: 30px;
  padding: 0 0.46153846em;
  border-bottom: 1px solid var(--VC-FG-3);
}
#__vconsole .vc-logbox .vc-group .vc-group-preview {
  -webkit-touch-callout: none;
}
#__vconsole .vc-logbox .vc-group .vc-group-preview:active {
  background-color: var(--VC-BG-COLOR-ACTIVE);
}
#__vconsole .vc-logbox .vc-group .vc-group-detail {
  display: none;
  padding: 0 0 0.76923077em 1.53846154em;
  border-bottom: 1px solid var(--VC-FG-3);
}
#__vconsole .vc-logbox .vc-group.vc-actived .vc-group-detail {
  display: block;
  background-color: var(--VC-BG-1);
}
#__vconsole .vc-logbox .vc-group.vc-actived .vc-table-row {
  background-color: var(--VC-BG-2);
}
#__vconsole .vc-logbox .vc-group.vc-actived .vc-group-preview {
  background-color: var(--VC-BG-1);
}
#__vconsole .vc-logbox .vc-table .vc-table-row {
  display: -webkit-box;
  display: -webkit-flex;
  display: -moz-box;
  display: -ms-flexbox;
  display: flex;
  -webkit-box-orient: horizontal;
  -webkit-box-direction: normal;
  -webkit-flex-direction: row;
  -moz-box-orient: horizontal;
  -moz-box-direction: normal;
  -ms-flex-direction: row;
  flex-direction: row;
  -webkit-flex-wrap: wrap;
  -ms-flex-wrap: wrap;
  flex-wrap: wrap;
  overflow: hidden;
  border-bottom: 1px solid var(--VC-FG-3);
}
#__vconsole .vc-logbox .vc-table .vc-table-row.vc-left-border {
  border-left: 1px solid var(--VC-FG-3);
}
#__vconsole .vc-logbox .vc-table .vc-table-col {
  -webkit-box-flex: 1;
  -webkit-flex: 1;
  -moz-box-flex: 1;
  -ms-flex: 1;
  flex: 1;
  padding: 0.23076923em 0.30769231em;
  border-left: 1px solid var(--VC-FG-3);
  overflow: auto;
  white-space: pre-wrap;
  word-break: break-word;
  /*white-space: nowrap;
        text-overflow: ellipsis;*/
  -webkit-overflow-scrolling: touch;
}
#__vconsole .vc-logbox .vc-table .vc-table-col:first-child {
  border: none;
}
#__vconsole .vc-logbox .vc-table .vc-small .vc-table-col {
  padding: 0 0.30769231em;
  font-size: 0.92307692em;
}
#__vconsole .vc-logbox .vc-table .vc-table-col-2 {
  -webkit-box-flex: 2;
  -webkit-flex: 2;
  -moz-box-flex: 2;
  -ms-flex: 2;
  flex: 2;
}
#__vconsole .vc-logbox .vc-table .vc-table-col-3 {
  -webkit-box-flex: 3;
  -webkit-flex: 3;
  -moz-box-flex: 3;
  -ms-flex: 3;
  flex: 3;
}
#__vconsole .vc-logbox .vc-table .vc-table-col-4 {
  -webkit-box-flex: 4;
  -webkit-flex: 4;
  -moz-box-flex: 4;
  -ms-flex: 4;
  flex: 4;
}
#__vconsole .vc-logbox .vc-table .vc-table-col-5 {
  -webkit-box-flex: 5;
  -webkit-flex: 5;
  -moz-box-flex: 5;
  -ms-flex: 5;
  flex: 5;
}
#__vconsole .vc-logbox .vc-table .vc-table-col-6 {
  -webkit-box-flex: 6;
  -webkit-flex: 6;
  -moz-box-flex: 6;
  -ms-flex: 6;
  flex: 6;
}
#__vconsole .vc-logbox .vc-table .vc-table-row-error {
  border-color: var(--VC-ERROR-BORDER);
  background-color: var(--VC-ERROR-BG);
}
#__vconsole .vc-logbox .vc-table .vc-table-row-error .vc-table-col {
  color: var(--VC-RED);
  border-color: var(--VC-ERROR-BORDER);
}
#__vconsole .vc-logbox .vc-table .vc-table-col-title {
  font-weight: bold;
}
#__vconsole .vc-logbox.vc-actived {
  display: block;
}
#__vconsole .vc-toolbar {
  border-top: 1px solid var(--VC-FG-3);
  line-height: 3em;
  position: absolute;
  left: 0;
  right: 0;
  bottom: 0;
  display: -webkit-box;
  display: -webkit-flex;
  display: -moz-box;
  display: -ms-flexbox;
  display: flex;
  -webkit-box-orient: horizontal;
  -webkit-box-direction: normal;
  -webkit-flex-direction: row;
  -moz-box-orient: horizontal;
  -moz-box-direction: normal;
  -ms-flex-direction: row;
  flex-direction: row;
}
#__vconsole .vc-toolbar .vc-tool {
  display: none;
  text-decoration: none;
  color: var(--VC-FG-0);
  width: 50%;
  -webkit-box-flex: 1;
  -webkit-flex: 1;
  -moz-box-flex: 1;
  -ms-flex: 1;
  flex: 1;
  text-align: center;
  position: relative;
  -webkit-touch-callout: none;
}
#__vconsole .vc-toolbar .vc-tool.vc-toggle,
#__vconsole .vc-toolbar .vc-tool.vc-global-tool {
  display: block;
}
#__vconsole .vc-toolbar .vc-tool:active {
  background-color: rgba(0, 0, 0, 0.15);
}
#__vconsole .vc-toolbar .vc-tool:after {
  content: " ";
  position: absolute;
  top: 0.53846154em;
  bottom: 0.53846154em;
  right: 0;
  border-left: 1px solid var(--VC-FG-3);
}
#__vconsole .vc-toolbar .vc-tool-last:after {
  border: none;
}
@supports (bottom: constant(safe-area-inset-bottom)) or (bottom: env(safe-area-inset-bottom)) {
  #__vconsole .vc-toolbar,
  #__vconsole .vc-switch {
    bottom: constant(safe-area-inset-bottom);
    bottom: env(safe-area-inset-bottom);
  }
}
#__vconsole.vc-toggle .vc-switch {
  display: none;
}
#__vconsole.vc-toggle .vc-mask {
  background: rgba(0, 0, 0, 0.6);
  display: block;
}
#__vconsole.vc-toggle .vc-panel {
  -webkit-transform: translate(0, 0);
  transform: translate(0, 0);
}
@media (prefers-color-scheme: dark) {
  #__vconsole:not([data-theme="light"]) {
    --VC-BG-0: #191919;
    --VC-BG-1: #1f1f1f;
    --VC-BG-2: #232323;
    --VC-BG-3: #2f2f2f;
    --VC-BG-4: #606060;
    --VC-BG-5: #2c2c2c;
    --VC-FG-0: rgba(255, 255, 255, 0.8);
    --VC-FG-HALF: rgba(255, 255, 255, 0.6);
    --VC-FG-1: rgba(255, 255, 255, 0.5);
    --VC-FG-2: rgba(255, 255, 255, 0.3);
    --VC-FG-3: rgba(255, 255, 255, 0.05);
    --VC-RED: #fa5151;
    --VC-ORANGE: #c87d2f;
    --VC-YELLOW: #cc9c00;
    --VC-GREEN: #74a800;
    --VC-LIGHTGREEN: #28b561;
    --VC-BRAND: #07c160;
    --VC-BLUE: #10aeff;
    --VC-INDIGO: #1196ff;
    --VC-PURPLE: #8183ff;
    --VC-LINK: #7d90a9;
    --VC-TEXTGREEN: #259c5c;
    --VC-FG: white;
    --VC-BG: black;
    --VC-BG-COLOR-ACTIVE: #282828;
    --VC-WARN-BG: #332700;
    --VC-WARN-BORDER: #664e00;
    --VC-ERROR-BG: #321010;
    --VC-ERROR-BORDER: #642020;
    --VC-DOM-TAG-NAME-COLOR: #5DB0D7;
    --VC-DOM-ATTRIBUTE-NAME-COLOR: #9BBBDC;
    --VC-DOM-ATTRIBUTE-VALUE-COLOR: #f29766;
    --VC-CODE-KEY-FG: #e36eec;
    --VC-CODE-PRIVATE-KEY-FG: #f4c5f7;
    --VC-CODE-FUNC-FG: #556af2;
    --VC-CODE-NUMBER-FG: #9980ff;
    --VC-CODE-STR-FG: #e93f3b;
    --VC-CODE-NULL-FG: #808080;
  }
}
#__vconsole[data-theme="dark"] {
  --VC-BG-0: #191919;
  --VC-BG-1: #1f1f1f;
  --VC-BG-2: #232323;
  --VC-BG-3: #2f2f2f;
  --VC-BG-4: #606060;
  --VC-BG-5: #2c2c2c;
  --VC-FG-0: rgba(255, 255, 255, 0.8);
  --VC-FG-HALF: rgba(255, 255, 255, 0.6);
  --VC-FG-1: rgba(255, 255, 255, 0.5);
  --VC-FG-2: rgba(255, 255, 255, 0.3);
  --VC-FG-3: rgba(255, 255, 255, 0.05);
  --VC-RED: #fa5151;
  --VC-ORANGE: #c87d2f;
  --VC-YELLOW: #cc9c00;
  --VC-GREEN: #74a800;
  --VC-LIGHTGREEN: #28b561;
  --VC-BRAND: #07c160;
  --VC-BLUE: #10aeff;
  --VC-INDIGO: #1196ff;
  --VC-PURPLE: #8183ff;
  --VC-LINK: #7d90a9;
  --VC-TEXTGREEN: #259c5c;
  --VC-FG: white;
  --VC-BG: black;
  --VC-BG-COLOR-ACTIVE: #282828;
  --VC-WARN-BG: #332700;
  --VC-WARN-BORDER: #664e00;
  --VC-ERROR-BG: #321010;
  --VC-ERROR-BORDER: #642020;
  --VC-DOM-TAG-NAME-COLOR: #5DB0D7;
  --VC-DOM-ATTRIBUTE-NAME-COLOR: #9BBBDC;
  --VC-DOM-ATTRIBUTE-VALUE-COLOR: #f29766;
  --VC-CODE-KEY-FG: #e36eec;
  --VC-CODE-PRIVATE-KEY-FG: #f4c5f7;
  --VC-CODE-FUNC-FG: #556af2;
  --VC-CODE-NUMBER-FG: #9980ff;
  --VC-CODE-STR-FG: #e93f3b;
  --VC-CODE-NULL-FG: #808080;
}
</style><style>/* color */
.vcelm-node {
  color: var(--VC-DOM-TAG-NAME-COLOR);
}
.vcelm-k {
  color: var(--VC-DOM-ATTRIBUTE-NAME-COLOR);
}
.vcelm-v {
  color: var(--VC-DOM-ATTRIBUTE-VALUE-COLOR);
}
/* layout */
.vcelm-l {
  padding-left: 8px;
  position: relative;
  word-wrap: break-word;
  line-height: 1;
}
/*.vcelm-l.vcelm-noc {
  padding-left: 0;
}*/
.vcelm-l.vc-toggle > .vcelm-node {
  display: block;
}
.vcelm-l .vcelm-node:active {
  background-color: var(--VC-BG-COLOR-ACTIVE);
}
.vcelm-l.vcelm-noc .vcelm-node:active {
  background-color: transparent;
}
.vcelm-t {
  white-space: pre-wrap;
  word-wrap: break-word;
}
/* level */
.vcelm-l .vcelm-l {
  display: none;
}
.vcelm-l.vc-toggle > .vcelm-l {
  margin-left: 4px;
  display: block;
}
/* arrow */
.vcelm-l:before {
  content: "";
  display: block;
  position: absolute;
  top: 6px;
  left: 3px;
  width: 0;
  height: 0;
  border: transparent solid 3px;
  border-left-color: var(--VC-FG-1);
}
.vcelm-l.vc-toggle:before {
  display: block;
  top: 6px;
  left: 0;
  border-top-color: var(--VC-FG-1);
  border-left-color: transparent;
}
.vcelm-l.vcelm-noc:before {
  display: none;
}
</style><script charset="utf-8" src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/vendors_layouts__index_p__Area__GDS-2020_p__Area__HarmonyOSForerunner_p__ArticleDetail_p__Home_p__Li_3868af9e.js.下载"></script><script charset="utf-8" src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/vendors_layouts__index_p__ArticleDetail_p__Live_p__QuestionDetail_p__Video.js.下载"></script><script charset="utf-8" src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/vendors_layouts__index.js.下载"></script><script charset="utf-8" src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/layouts__index_p__Live__Add_p__Video__Add_p__Write.js.下载"></script><script charset="utf-8" src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/layouts__index.js.下载"></script><script charset="utf-8" src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/4.js.下载"></script><link rel="stylesheet" type="text/css" href="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/vendors_p__ArticleDetail.chunk.css"><script charset="utf-8" src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/vendors_p__ArticleDetail.js.下载"></script><script charset="utf-8" src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/p__ArticleDetail.js.下载"></script><script charset="utf-8" src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/54.js.下载"></script><link rel="stylesheet" type="text/css" href="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/3.chunk.css"><script charset="utf-8" src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/3.js.下载"></script><script charset="utf-8" src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/6.js.下载"></script><script charset="utf-8" src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/9.js.下载"></script><meta name="twitter:image" content="https://cdn.segmentfault.com/r-18a99036/touch-icon.png" data-react-helmet="true"><meta name="og:image" content="https://cdn.segmentfault.com/r-18a99036/touch-icon.png" data-react-helmet="true"><meta name="event-object" value="{&quot;current&quot;: [&quot;article&quot;, [&quot;1190000015739343&quot;]], &quot;root&quot;: [&quot;article&quot;, &quot;1190000015739343&quot;]}" id="SFEventObject" data-react-helmet="true"><script type="application/ld+json" data-react-helmet="true">{
            "@context": "https://schema.org",
            "@type": "Article",
            "mainEntityOfPage": {
              "@type": "WebPage",
              "@id": "https://google.com/article"
            },
            "name": "逐行分析AQS源码(1)——独占锁的获取",
            "headline": "逐行分析AQS源码(1)——独占锁的获取",
            "image": "https://cdn.segmentfault.com/r-18a99036/touch-icon.png",
            "datePublished": "2018-07-23T13:57:53.000Z",
            "dateModified": "2018-09-18T15:30:05.000Z",
            "url": "https://segmentfault.com/a/1190000015739343",
            "author": {
              "@type": "Person",
              "name": "ChiuCheng"
            },
            "publisher": {
              "@type": "Organization",
              "name": "SegmentFault",
              "logo": {
                "@type": "ImageObject",
                "url":
                  "https://assets.segmentfault.com/v-5fc4b0b2/global/img/static/touch-icon.png"
              }
            }
          }</script><script src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/katexCssLoader.js.下载"></script><style type="text/css">
/* stylelint-disable font-family-no-missing-generic-family-keyword */
@font-face {
  font-family: 'KaTeX_AMS';
  src: url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_AMS-Regular.woff2) format('woff2'), url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_AMS-Regular.woff) format('woff'), url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_AMS-Regular.ttf) format('truetype');
  font-weight: normal;
  font-style: normal;
}
@font-face {
  font-family: 'KaTeX_Caligraphic';
  src: url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Caligraphic-Bold.woff2) format('woff2'), url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Caligraphic-Bold.woff) format('woff'), url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Caligraphic-Bold.ttf) format('truetype');
  font-weight: bold;
  font-style: normal;
}
@font-face {
  font-family: 'KaTeX_Caligraphic';
  src: url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Caligraphic-Regular.woff2) format('woff2'), url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Caligraphic-Regular.woff) format('woff'), url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Caligraphic-Regular.ttf) format('truetype');
  font-weight: normal;
  font-style: normal;
}
@font-face {
  font-family: 'KaTeX_Fraktur';
  src: url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Fraktur-Bold.woff2) format('woff2'), url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Fraktur-Bold.woff) format('woff'), url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Fraktur-Bold.ttf) format('truetype');
  font-weight: bold;
  font-style: normal;
}
@font-face {
  font-family: 'KaTeX_Fraktur';
  src: url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Fraktur-Regular.woff2) format('woff2'), url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Fraktur-Regular.woff) format('woff'), url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Fraktur-Regular.ttf) format('truetype');
  font-weight: normal;
  font-style: normal;
}
@font-face {
  font-family: 'KaTeX_Main';
  src: url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Main-Bold.woff2) format('woff2'), url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Main-Bold.woff) format('woff'), url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Main-Bold.ttf) format('truetype');
  font-weight: bold;
  font-style: normal;
}
@font-face {
  font-family: 'KaTeX_Main';
  src: url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Main-BoldItalic.woff2) format('woff2'), url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Main-BoldItalic.woff) format('woff'), url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Main-BoldItalic.ttf) format('truetype');
  font-weight: bold;
  font-style: italic;
}
@font-face {
  font-family: 'KaTeX_Main';
  src: url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Main-Italic.woff2) format('woff2'), url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Main-Italic.woff) format('woff'), url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Main-Italic.ttf) format('truetype');
  font-weight: normal;
  font-style: italic;
}
@font-face {
  font-family: 'KaTeX_Main';
  src: url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Main-Regular.woff2) format('woff2'), url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Main-Regular.woff) format('woff'), url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Main-Regular.ttf) format('truetype');
  font-weight: normal;
  font-style: normal;
}
@font-face {
  font-family: 'KaTeX_Math';
  src: url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Math-BoldItalic.woff2) format('woff2'), url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Math-BoldItalic.woff) format('woff'), url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Math-BoldItalic.ttf) format('truetype');
  font-weight: bold;
  font-style: italic;
}
@font-face {
  font-family: 'KaTeX_Math';
  src: url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Math-Italic.woff2) format('woff2'), url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Math-Italic.woff) format('woff'), url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Math-Italic.ttf) format('truetype');
  font-weight: normal;
  font-style: italic;
}
@font-face {
  font-family: 'KaTeX_SansSerif';
  src: url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_SansSerif-Bold.woff2) format('woff2'), url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_SansSerif-Bold.woff) format('woff'), url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_SansSerif-Bold.ttf) format('truetype');
  font-weight: bold;
  font-style: normal;
}
@font-face {
  font-family: 'KaTeX_SansSerif';
  src: url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_SansSerif-Italic.woff2) format('woff2'), url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_SansSerif-Italic.woff) format('woff'), url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_SansSerif-Italic.ttf) format('truetype');
  font-weight: normal;
  font-style: italic;
}
@font-face {
  font-family: 'KaTeX_SansSerif';
  src: url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_SansSerif-Regular.woff2) format('woff2'), url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_SansSerif-Regular.woff) format('woff'), url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_SansSerif-Regular.ttf) format('truetype');
  font-weight: normal;
  font-style: normal;
}
@font-face {
  font-family: 'KaTeX_Script';
  src: url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Script-Regular.woff2) format('woff2'), url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Script-Regular.woff) format('woff'), url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Script-Regular.ttf) format('truetype');
  font-weight: normal;
  font-style: normal;
}
@font-face {
  font-family: 'KaTeX_Size1';
  src: url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Size1-Regular.woff2) format('woff2'), url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Size1-Regular.woff) format('woff'), url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Size1-Regular.ttf) format('truetype');
  font-weight: normal;
  font-style: normal;
}
@font-face {
  font-family: 'KaTeX_Size2';
  src: url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Size2-Regular.woff2) format('woff2'), url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Size2-Regular.woff) format('woff'), url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Size2-Regular.ttf) format('truetype');
  font-weight: normal;
  font-style: normal;
}
@font-face {
  font-family: 'KaTeX_Size3';
  src: url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Size3-Regular.woff2) format('woff2'), url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Size3-Regular.woff) format('woff'), url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Size3-Regular.ttf) format('truetype');
  font-weight: normal;
  font-style: normal;
}
@font-face {
  font-family: 'KaTeX_Size4';
  src: url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Size4-Regular.woff2) format('woff2'), url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Size4-Regular.woff) format('woff'), url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Size4-Regular.ttf) format('truetype');
  font-weight: normal;
  font-style: normal;
}
@font-face {
  font-family: 'KaTeX_Typewriter';
  src: url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Typewriter-Regular.woff2) format('woff2'), url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Typewriter-Regular.woff) format('woff'), url(https://cdn.segmentfault.com/r-18a99036/fonts/katex/KaTeX_Typewriter-Regular.ttf) format('truetype');
  font-weight: normal;
  font-style: normal;
}
.katex {
  font: normal 1.21em KaTeX_Main, Times New Roman, serif;
  line-height: 1.2;
  text-indent: 0;
  text-rendering: auto;
  border-color: currentColor;
}
.katex * {
  -ms-high-contrast-adjust: none !important;
}
.katex .katex-version::after {
  content: "0.12.0";
}
.katex .katex-mathml {
  position: absolute;
  clip: rect(1px, 1px, 1px, 1px);
  padding: 0;
  border: 0;
  height: 1px;
  width: 1px;
  overflow: hidden;
}
.katex .katex-html {
  /* 
ewline is an empty block at top level, between .base elements */
}
.katex .katex-html > .newline {
  display: block;
}
.katex .base {
  position: relative;
  display: inline-block;
  white-space: nowrap;
  width: min-content;
}
.katex .strut {
  display: inline-block;
}
.katex .textbf {
  font-weight: bold;
}
.katex .textit {
  font-style: italic;
}
.katex .textrm {
  font-family: KaTeX_Main;
}
.katex .textsf {
  font-family: KaTeX_SansSerif;
}
.katex .texttt {
  font-family: KaTeX_Typewriter;
}
.katex .mathnormal {
  font-family: KaTeX_Math;
  font-style: italic;
}
.katex .mathit {
  font-family: KaTeX_Main;
  font-style: italic;
}
.katex .mathrm {
  font-style: normal;
}
.katex .mathbf {
  font-family: KaTeX_Main;
  font-weight: bold;
}
.katex .boldsymbol {
  font-family: KaTeX_Math;
  font-weight: bold;
  font-style: italic;
}
.katex .amsrm {
  font-family: KaTeX_AMS;
}
.katex .mathbb,
.katex .textbb {
  font-family: KaTeX_AMS;
}
.katex .mathcal {
  font-family: KaTeX_Caligraphic;
}
.katex .mathfrak,
.katex .textfrak {
  font-family: KaTeX_Fraktur;
}
.katex .mathtt {
  font-family: KaTeX_Typewriter;
}
.katex .mathscr,
.katex .textscr {
  font-family: KaTeX_Script;
}
.katex .mathsf,
.katex .textsf {
  font-family: KaTeX_SansSerif;
}
.katex .mathboldsf,
.katex .textboldsf {
  font-family: KaTeX_SansSerif;
  font-weight: bold;
}
.katex .mathitsf,
.katex .textitsf {
  font-family: KaTeX_SansSerif;
  font-style: italic;
}
.katex .mainrm {
  font-family: KaTeX_Main;
  font-style: normal;
}
.katex .vlist-t {
  display: inline-table;
  table-layout: fixed;
  border-collapse: collapse;
}
.katex .vlist-r {
  display: table-row;
}
.katex .vlist {
  display: table-cell;
  vertical-align: bottom;
  position: relative;
}
.katex .vlist > span {
  display: block;
  height: 0;
  position: relative;
}
.katex .vlist > span > span {
  display: inline-block;
}
.katex .vlist > span > .pstrut {
  overflow: hidden;
  width: 0;
}
.katex .vlist-t2 {
  margin-right: -2px;
}
.katex .vlist-s {
  display: table-cell;
  vertical-align: bottom;
  font-size: 1px;
  width: 2px;
  min-width: 2px;
}
.katex .vbox {
  display: -ms-inline-flexbox;
  display: inline-flex;
  -ms-flex-direction: column;
  flex-direction: column;
  align-items: baseline;
}
.katex .hbox {
  display: -ms-inline-flexbox;
  display: inline-flex;
  -ms-flex-direction: row;
  flex-direction: row;
  width: 100%;
}
.katex .thinbox {
  display: inline-flex;
  flex-direction: row;
  width: 0;
  max-width: 0;
}
.katex .msupsub {
  text-align: left;
}
.katex .mfrac > span > span {
  text-align: center;
}
.katex .mfrac .frac-line {
  display: inline-block;
  width: 100%;
  border-bottom-style: solid;
}
.katex .mfrac .frac-line,
.katex .overline .overline-line,
.katex .underline .underline-line,
.katex .hline,
.katex .hdashline,
.katex .rule {
  min-height: 1px;
}
.katex .mspace {
  display: inline-block;
}
.katex .llap,
.katex .rlap,
.katex .clap {
  width: 0;
  position: relative;
}
.katex .llap > .inner,
.katex .rlap > .inner,
.katex .clap > .inner {
  position: absolute;
}
.katex .llap > .fix,
.katex .rlap > .fix,
.katex .clap > .fix {
  display: inline-block;
}
.katex .llap > .inner {
  right: 0;
}
.katex .rlap > .inner,
.katex .clap > .inner {
  left: 0;
}
.katex .clap > .inner > span {
  margin-left: -50%;
  margin-right: 50%;
}
.katex .rule {
  display: inline-block;
  border: solid 0;
  position: relative;
}
.katex .overline .overline-line,
.katex .underline .underline-line,
.katex .hline {
  display: inline-block;
  width: 100%;
  border-bottom-style: solid;
}
.katex .hdashline {
  display: inline-block;
  width: 100%;
  border-bottom-style: dashed;
}
.katex .sqrt > .root {
  margin-left: 0.27777778em;
  margin-right: -0.55555556em;
}
.katex .sizing.reset-size1.size1,
.katex .fontsize-ensurer.reset-size1.size1 {
  font-size: 1em;
}
.katex .sizing.reset-size1.size2,
.katex .fontsize-ensurer.reset-size1.size2 {
  font-size: 1.2em;
}
.katex .sizing.reset-size1.size3,
.katex .fontsize-ensurer.reset-size1.size3 {
  font-size: 1.4em;
}
.katex .sizing.reset-size1.size4,
.katex .fontsize-ensurer.reset-size1.size4 {
  font-size: 1.6em;
}
.katex .sizing.reset-size1.size5,
.katex .fontsize-ensurer.reset-size1.size5 {
  font-size: 1.8em;
}
.katex .sizing.reset-size1.size6,
.katex .fontsize-ensurer.reset-size1.size6 {
  font-size: 2em;
}
.katex .sizing.reset-size1.size7,
.katex .fontsize-ensurer.reset-size1.size7 {
  font-size: 2.4em;
}
.katex .sizing.reset-size1.size8,
.katex .fontsize-ensurer.reset-size1.size8 {
  font-size: 2.88em;
}
.katex .sizing.reset-size1.size9,
.katex .fontsize-ensurer.reset-size1.size9 {
  font-size: 3.456em;
}
.katex .sizing.reset-size1.size10,
.katex .fontsize-ensurer.reset-size1.size10 {
  font-size: 4.148em;
}
.katex .sizing.reset-size1.size11,
.katex .fontsize-ensurer.reset-size1.size11 {
  font-size: 4.976em;
}
.katex .sizing.reset-size2.size1,
.katex .fontsize-ensurer.reset-size2.size1 {
  font-size: 0.83333333em;
}
.katex .sizing.reset-size2.size2,
.katex .fontsize-ensurer.reset-size2.size2 {
  font-size: 1em;
}
.katex .sizing.reset-size2.size3,
.katex .fontsize-ensurer.reset-size2.size3 {
  font-size: 1.16666667em;
}
.katex .sizing.reset-size2.size4,
.katex .fontsize-ensurer.reset-size2.size4 {
  font-size: 1.33333333em;
}
.katex .sizing.reset-size2.size5,
.katex .fontsize-ensurer.reset-size2.size5 {
  font-size: 1.5em;
}
.katex .sizing.reset-size2.size6,
.katex .fontsize-ensurer.reset-size2.size6 {
  font-size: 1.66666667em;
}
.katex .sizing.reset-size2.size7,
.katex .fontsize-ensurer.reset-size2.size7 {
  font-size: 2em;
}
.katex .sizing.reset-size2.size8,
.katex .fontsize-ensurer.reset-size2.size8 {
  font-size: 2.4em;
}
.katex .sizing.reset-size2.size9,
.katex .fontsize-ensurer.reset-size2.size9 {
  font-size: 2.88em;
}
.katex .sizing.reset-size2.size10,
.katex .fontsize-ensurer.reset-size2.size10 {
  font-size: 3.45666667em;
}
.katex .sizing.reset-size2.size11,
.katex .fontsize-ensurer.reset-size2.size11 {
  font-size: 4.14666667em;
}
.katex .sizing.reset-size3.size1,
.katex .fontsize-ensurer.reset-size3.size1 {
  font-size: 0.71428571em;
}
.katex .sizing.reset-size3.size2,
.katex .fontsize-ensurer.reset-size3.size2 {
  font-size: 0.85714286em;
}
.katex .sizing.reset-size3.size3,
.katex .fontsize-ensurer.reset-size3.size3 {
  font-size: 1em;
}
.katex .sizing.reset-size3.size4,
.katex .fontsize-ensurer.reset-size3.size4 {
  font-size: 1.14285714em;
}
.katex .sizing.reset-size3.size5,
.katex .fontsize-ensurer.reset-size3.size5 {
  font-size: 1.28571429em;
}
.katex .sizing.reset-size3.size6,
.katex .fontsize-ensurer.reset-size3.size6 {
  font-size: 1.42857143em;
}
.katex .sizing.reset-size3.size7,
.katex .fontsize-ensurer.reset-size3.size7 {
  font-size: 1.71428571em;
}
.katex .sizing.reset-size3.size8,
.katex .fontsize-ensurer.reset-size3.size8 {
  font-size: 2.05714286em;
}
.katex .sizing.reset-size3.size9,
.katex .fontsize-ensurer.reset-size3.size9 {
  font-size: 2.46857143em;
}
.katex .sizing.reset-size3.size10,
.katex .fontsize-ensurer.reset-size3.size10 {
  font-size: 2.96285714em;
}
.katex .sizing.reset-size3.size11,
.katex .fontsize-ensurer.reset-size3.size11 {
  font-size: 3.55428571em;
}
.katex .sizing.reset-size4.size1,
.katex .fontsize-ensurer.reset-size4.size1 {
  font-size: 0.625em;
}
.katex .sizing.reset-size4.size2,
.katex .fontsize-ensurer.reset-size4.size2 {
  font-size: 0.75em;
}
.katex .sizing.reset-size4.size3,
.katex .fontsize-ensurer.reset-size4.size3 {
  font-size: 0.875em;
}
.katex .sizing.reset-size4.size4,
.katex .fontsize-ensurer.reset-size4.size4 {
  font-size: 1em;
}
.katex .sizing.reset-size4.size5,
.katex .fontsize-ensurer.reset-size4.size5 {
  font-size: 1.125em;
}
.katex .sizing.reset-size4.size6,
.katex .fontsize-ensurer.reset-size4.size6 {
  font-size: 1.25em;
}
.katex .sizing.reset-size4.size7,
.katex .fontsize-ensurer.reset-size4.size7 {
  font-size: 1.5em;
}
.katex .sizing.reset-size4.size8,
.katex .fontsize-ensurer.reset-size4.size8 {
  font-size: 1.8em;
}
.katex .sizing.reset-size4.size9,
.katex .fontsize-ensurer.reset-size4.size9 {
  font-size: 2.16em;
}
.katex .sizing.reset-size4.size10,
.katex .fontsize-ensurer.reset-size4.size10 {
  font-size: 2.5925em;
}
.katex .sizing.reset-size4.size11,
.katex .fontsize-ensurer.reset-size4.size11 {
  font-size: 3.11em;
}
.katex .sizing.reset-size5.size1,
.katex .fontsize-ensurer.reset-size5.size1 {
  font-size: 0.55555556em;
}
.katex .sizing.reset-size5.size2,
.katex .fontsize-ensurer.reset-size5.size2 {
  font-size: 0.66666667em;
}
.katex .sizing.reset-size5.size3,
.katex .fontsize-ensurer.reset-size5.size3 {
  font-size: 0.77777778em;
}
.katex .sizing.reset-size5.size4,
.katex .fontsize-ensurer.reset-size5.size4 {
  font-size: 0.88888889em;
}
.katex .sizing.reset-size5.size5,
.katex .fontsize-ensurer.reset-size5.size5 {
  font-size: 1em;
}
.katex .sizing.reset-size5.size6,
.katex .fontsize-ensurer.reset-size5.size6 {
  font-size: 1.11111111em;
}
.katex .sizing.reset-size5.size7,
.katex .fontsize-ensurer.reset-size5.size7 {
  font-size: 1.33333333em;
}
.katex .sizing.reset-size5.size8,
.katex .fontsize-ensurer.reset-size5.size8 {
  font-size: 1.6em;
}
.katex .sizing.reset-size5.size9,
.katex .fontsize-ensurer.reset-size5.size9 {
  font-size: 1.92em;
}
.katex .sizing.reset-size5.size10,
.katex .fontsize-ensurer.reset-size5.size10 {
  font-size: 2.30444444em;
}
.katex .sizing.reset-size5.size11,
.katex .fontsize-ensurer.reset-size5.size11 {
  font-size: 2.76444444em;
}
.katex .sizing.reset-size6.size1,
.katex .fontsize-ensurer.reset-size6.size1 {
  font-size: 0.5em;
}
.katex .sizing.reset-size6.size2,
.katex .fontsize-ensurer.reset-size6.size2 {
  font-size: 0.6em;
}
.katex .sizing.reset-size6.size3,
.katex .fontsize-ensurer.reset-size6.size3 {
  font-size: 0.7em;
}
.katex .sizing.reset-size6.size4,
.katex .fontsize-ensurer.reset-size6.size4 {
  font-size: 0.8em;
}
.katex .sizing.reset-size6.size5,
.katex .fontsize-ensurer.reset-size6.size5 {
  font-size: 0.9em;
}
.katex .sizing.reset-size6.size6,
.katex .fontsize-ensurer.reset-size6.size6 {
  font-size: 1em;
}
.katex .sizing.reset-size6.size7,
.katex .fontsize-ensurer.reset-size6.size7 {
  font-size: 1.2em;
}
.katex .sizing.reset-size6.size8,
.katex .fontsize-ensurer.reset-size6.size8 {
  font-size: 1.44em;
}
.katex .sizing.reset-size6.size9,
.katex .fontsize-ensurer.reset-size6.size9 {
  font-size: 1.728em;
}
.katex .sizing.reset-size6.size10,
.katex .fontsize-ensurer.reset-size6.size10 {
  font-size: 2.074em;
}
.katex .sizing.reset-size6.size11,
.katex .fontsize-ensurer.reset-size6.size11 {
  font-size: 2.488em;
}
.katex .sizing.reset-size7.size1,
.katex .fontsize-ensurer.reset-size7.size1 {
  font-size: 0.41666667em;
}
.katex .sizing.reset-size7.size2,
.katex .fontsize-ensurer.reset-size7.size2 {
  font-size: 0.5em;
}
.katex .sizing.reset-size7.size3,
.katex .fontsize-ensurer.reset-size7.size3 {
  font-size: 0.58333333em;
}
.katex .sizing.reset-size7.size4,
.katex .fontsize-ensurer.reset-size7.size4 {
  font-size: 0.66666667em;
}
.katex .sizing.reset-size7.size5,
.katex .fontsize-ensurer.reset-size7.size5 {
  font-size: 0.75em;
}
.katex .sizing.reset-size7.size6,
.katex .fontsize-ensurer.reset-size7.size6 {
  font-size: 0.83333333em;
}
.katex .sizing.reset-size7.size7,
.katex .fontsize-ensurer.reset-size7.size7 {
  font-size: 1em;
}
.katex .sizing.reset-size7.size8,
.katex .fontsize-ensurer.reset-size7.size8 {
  font-size: 1.2em;
}
.katex .sizing.reset-size7.size9,
.katex .fontsize-ensurer.reset-size7.size9 {
  font-size: 1.44em;
}
.katex .sizing.reset-size7.size10,
.katex .fontsize-ensurer.reset-size7.size10 {
  font-size: 1.72833333em;
}
.katex .sizing.reset-size7.size11,
.katex .fontsize-ensurer.reset-size7.size11 {
  font-size: 2.07333333em;
}
.katex .sizing.reset-size8.size1,
.katex .fontsize-ensurer.reset-size8.size1 {
  font-size: 0.34722222em;
}
.katex .sizing.reset-size8.size2,
.katex .fontsize-ensurer.reset-size8.size2 {
  font-size: 0.41666667em;
}
.katex .sizing.reset-size8.size3,
.katex .fontsize-ensurer.reset-size8.size3 {
  font-size: 0.48611111em;
}
.katex .sizing.reset-size8.size4,
.katex .fontsize-ensurer.reset-size8.size4 {
  font-size: 0.55555556em;
}
.katex .sizing.reset-size8.size5,
.katex .fontsize-ensurer.reset-size8.size5 {
  font-size: 0.625em;
}
.katex .sizing.reset-size8.size6,
.katex .fontsize-ensurer.reset-size8.size6 {
  font-size: 0.69444444em;
}
.katex .sizing.reset-size8.size7,
.katex .fontsize-ensurer.reset-size8.size7 {
  font-size: 0.83333333em;
}
.katex .sizing.reset-size8.size8,
.katex .fontsize-ensurer.reset-size8.size8 {
  font-size: 1em;
}
.katex .sizing.reset-size8.size9,
.katex .fontsize-ensurer.reset-size8.size9 {
  font-size: 1.2em;
}
.katex .sizing.reset-size8.size10,
.katex .fontsize-ensurer.reset-size8.size10 {
  font-size: 1.44027778em;
}
.katex .sizing.reset-size8.size11,
.katex .fontsize-ensurer.reset-size8.size11 {
  font-size: 1.72777778em;
}
.katex .sizing.reset-size9.size1,
.katex .fontsize-ensurer.reset-size9.size1 {
  font-size: 0.28935185em;
}
.katex .sizing.reset-size9.size2,
.katex .fontsize-ensurer.reset-size9.size2 {
  font-size: 0.34722222em;
}
.katex .sizing.reset-size9.size3,
.katex .fontsize-ensurer.reset-size9.size3 {
  font-size: 0.40509259em;
}
.katex .sizing.reset-size9.size4,
.katex .fontsize-ensurer.reset-size9.size4 {
  font-size: 0.46296296em;
}
.katex .sizing.reset-size9.size5,
.katex .fontsize-ensurer.reset-size9.size5 {
  font-size: 0.52083333em;
}
.katex .sizing.reset-size9.size6,
.katex .fontsize-ensurer.reset-size9.size6 {
  font-size: 0.5787037em;
}
.katex .sizing.reset-size9.size7,
.katex .fontsize-ensurer.reset-size9.size7 {
  font-size: 0.69444444em;
}
.katex .sizing.reset-size9.size8,
.katex .fontsize-ensurer.reset-size9.size8 {
  font-size: 0.83333333em;
}
.katex .sizing.reset-size9.size9,
.katex .fontsize-ensurer.reset-size9.size9 {
  font-size: 1em;
}
.katex .sizing.reset-size9.size10,
.katex .fontsize-ensurer.reset-size9.size10 {
  font-size: 1.20023148em;
}
.katex .sizing.reset-size9.size11,
.katex .fontsize-ensurer.reset-size9.size11 {
  font-size: 1.43981481em;
}
.katex .sizing.reset-size10.size1,
.katex .fontsize-ensurer.reset-size10.size1 {
  font-size: 0.24108004em;
}
.katex .sizing.reset-size10.size2,
.katex .fontsize-ensurer.reset-size10.size2 {
  font-size: 0.28929605em;
}
.katex .sizing.reset-size10.size3,
.katex .fontsize-ensurer.reset-size10.size3 {
  font-size: 0.33751205em;
}
.katex .sizing.reset-size10.size4,
.katex .fontsize-ensurer.reset-size10.size4 {
  font-size: 0.38572806em;
}
.katex .sizing.reset-size10.size5,
.katex .fontsize-ensurer.reset-size10.size5 {
  font-size: 0.43394407em;
}
.katex .sizing.reset-size10.size6,
.katex .fontsize-ensurer.reset-size10.size6 {
  font-size: 0.48216008em;
}
.katex .sizing.reset-size10.size7,
.katex .fontsize-ensurer.reset-size10.size7 {
  font-size: 0.57859209em;
}
.katex .sizing.reset-size10.size8,
.katex .fontsize-ensurer.reset-size10.size8 {
  font-size: 0.69431051em;
}
.katex .sizing.reset-size10.size9,
.katex .fontsize-ensurer.reset-size10.size9 {
  font-size: 0.83317261em;
}
.katex .sizing.reset-size10.size10,
.katex .fontsize-ensurer.reset-size10.size10 {
  font-size: 1em;
}
.katex .sizing.reset-size10.size11,
.katex .fontsize-ensurer.reset-size10.size11 {
  font-size: 1.19961427em;
}
.katex .sizing.reset-size11.size1,
.katex .fontsize-ensurer.reset-size11.size1 {
  font-size: 0.20096463em;
}
.katex .sizing.reset-size11.size2,
.katex .fontsize-ensurer.reset-size11.size2 {
  font-size: 0.24115756em;
}
.katex .sizing.reset-size11.size3,
.katex .fontsize-ensurer.reset-size11.size3 {
  font-size: 0.28135048em;
}
.katex .sizing.reset-size11.size4,
.katex .fontsize-ensurer.reset-size11.size4 {
  font-size: 0.32154341em;
}
.katex .sizing.reset-size11.size5,
.katex .fontsize-ensurer.reset-size11.size5 {
  font-size: 0.36173633em;
}
.katex .sizing.reset-size11.size6,
.katex .fontsize-ensurer.reset-size11.size6 {
  font-size: 0.40192926em;
}
.katex .sizing.reset-size11.size7,
.katex .fontsize-ensurer.reset-size11.size7 {
  font-size: 0.48231511em;
}
.katex .sizing.reset-size11.size8,
.katex .fontsize-ensurer.reset-size11.size8 {
  font-size: 0.57877814em;
}
.katex .sizing.reset-size11.size9,
.katex .fontsize-ensurer.reset-size11.size9 {
  font-size: 0.69453376em;
}
.katex .sizing.reset-size11.size10,
.katex .fontsize-ensurer.reset-size11.size10 {
  font-size: 0.83360129em;
}
.katex .sizing.reset-size11.size11,
.katex .fontsize-ensurer.reset-size11.size11 {
  font-size: 1em;
}
.katex .delimsizing.size1 {
  font-family: KaTeX_Size1;
}
.katex .delimsizing.size2 {
  font-family: KaTeX_Size2;
}
.katex .delimsizing.size3 {
  font-family: KaTeX_Size3;
}
.katex .delimsizing.size4 {
  font-family: KaTeX_Size4;
}
.katex .delimsizing.mult .delim-size1 > span {
  font-family: KaTeX_Size1;
}
.katex .delimsizing.mult .delim-size4 > span {
  font-family: KaTeX_Size4;
}
.katex .nulldelimiter {
  display: inline-block;
  width: 0.12em;
}
.katex .delimcenter {
  position: relative;
}
.katex .op-symbol {
  position: relative;
}
.katex .op-symbol.small-op {
  font-family: KaTeX_Size1;
}
.katex .op-symbol.large-op {
  font-family: KaTeX_Size2;
}
.katex .op-limits > .vlist-t {
  text-align: center;
}
.katex .accent > .vlist-t {
  text-align: center;
}
.katex .accent .accent-body {
  position: relative;
}
.katex .accent .accent-body:not(.accent-full) {
  width: 0;
}
.katex .overlay {
  display: block;
}
.katex .mtable .vertical-separator {
  display: inline-block;
  min-width: 1px;
}
.katex .mtable .arraycolsep {
  display: inline-block;
}
.katex .mtable .col-align-c > .vlist-t {
  text-align: center;
}
.katex .mtable .col-align-l > .vlist-t {
  text-align: left;
}
.katex .mtable .col-align-r > .vlist-t {
  text-align: right;
}
.katex .svg-align {
  text-align: left;
}
.katex svg {
  display: block;
  position: absolute;
  width: 100%;
  height: inherit;
  fill: currentColor;
  stroke: currentColor;
  fill-rule: nonzero;
  fill-opacity: 1;
  stroke-width: 1;
  stroke-linecap: butt;
  stroke-linejoin: miter;
  stroke-miterlimit: 4;
  stroke-dasharray: none;
  stroke-dashoffset: 0;
  stroke-opacity: 1;
}
.katex svg path {
  stroke: none;
}
.katex img {
  border-style: none;
  min-width: 0;
  min-height: 0;
  max-width: none;
  max-height: none;
}
.katex .stretchy {
  width: 100%;
  display: block;
  position: relative;
  overflow: hidden;
}
.katex .stretchy::before,
.katex .stretchy::after {
  content: "";
}
.katex .hide-tail {
  width: 100%;
  position: relative;
  overflow: hidden;
}
.katex .halfarrow-left {
  position: absolute;
  left: 0;
  width: 50.2%;
  overflow: hidden;
}
.katex .halfarrow-right {
  position: absolute;
  right: 0;
  width: 50.2%;
  overflow: hidden;
}
.katex .brace-left {
  position: absolute;
  left: 0;
  width: 25.1%;
  overflow: hidden;
}
.katex .brace-center {
  position: absolute;
  left: 25%;
  width: 50%;
  overflow: hidden;
}
.katex .brace-right {
  position: absolute;
  right: 0;
  width: 25.1%;
  overflow: hidden;
}
.katex .x-arrow-pad {
  padding: 0 0.5em;
}
.katex .x-arrow,
.katex .mover,
.katex .munder {
  text-align: center;
}
.katex .boxpad {
  padding: 0 0.3em 0 0.3em;
}
.katex .fbox,
.katex .fcolorbox {
  box-sizing: border-box;
  border: 0.04em solid;
}
.katex .cancel-pad {
  padding: 0 0.2em 0 0.2em;
}
.katex .cancel-lap {
  margin-left: -0.2em;
  margin-right: -0.2em;
}
.katex .sout {
  border-bottom-style: solid;
  border-bottom-width: 0.08em;
}
.katex-display {
  display: block;
  margin: 1em 0;
  text-align: center;
}
.katex-display > .katex {
  display: block;
  text-align: center;
  white-space: nowrap;
}
.katex-display > .katex > .katex-html {
  display: block;
  position: relative;
}
.katex-display > .katex > .katex-html > .tag {
  position: absolute;
  right: 0;
}
.katex-display.leqno > .katex > .katex-html > .tag {
  left: 0;
  right: auto;
}
.katex-display.fleqn > .katex {
  text-align: left;
  padding-left: 2em;
}
</style><meta http-equiv="origin-trial" content="A9ZgbRtm4pU3oZiuNzOsKcC8ppFSZdcjP2qYcdQrFKVzkmiWH1kdYY1Mi9x7G8+PS8HV9Ha9Cz0gaMdKsiVZIgMAAAB7eyJvcmlnaW4iOiJodHRwczovL2RvdWJsZWNsaWNrLm5ldDo0NDMiLCJmZWF0dXJlIjoiVHJ1c3RUb2tlbnMiLCJleHBpcnkiOjE2MjYyMjA3OTksImlzU3ViZG9tYWluIjp0cnVlLCJpc1RoaXJkUGFydHkiOnRydWV9"><meta http-equiv="origin-trial" content="A3HucHUo1oW9s+9kIKz8mLkbcmdaj5lxt3eiIMp1Nh49dkkBlg1Fhg4Fd/r0vL69mRRA36YutI9P/lJUfL8csQoAAACFeyJvcmlnaW4iOiJodHRwczovL2RvdWJsZWNsaWNrLm5ldDo0NDMiLCJmZWF0dXJlIjoiQ29udmVyc2lvbk1lYXN1cmVtZW50IiwiZXhwaXJ5IjoxNjI2MjIwNzk5LCJpc1N1YmRvbWFpbiI6dHJ1ZSwiaXNUaGlyZFBhcnR5Ijp0cnVlfQ=="><link rel="preload" href="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/f(7).txt" as="script"><script type="text/javascript" src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/f(7).txt"></script></head>
  <body>
    <div id="root"><div class="d-none d-lg-block text-center"><div id="OA_holder_5" class="ad-container" style="display:block"><div id="beacon_140e19828b" style="position: absolute; left: 0px; top: 0px; visibility: hidden;"><img src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/lg.php" width="0" height="0" alt="" style="width: 0px; height: 0px;"></div>
</div></div><div id="root-top-container"></div><nav id="sf-header" class="bg-white shadow-sm sticky-top navbar navbar-expand-lg navbar-light"><div class="container"><a href="https://segmentfault.com/" class="navbar-brand"><img src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/logo-b.d865fc97.svg" width="139" height="26" class="d-inline-block" alt="segmentfault"></a><a class="btn btn-primary d-lg-none ml-auto mr-2" href="https://segmentfault.com/user/login">注册登录</a><button aria-controls="basic-navbar-nav" type="button" aria-label="Toggle navigation" class="navbar-toggler collapsed"><span class="navbar-toggler-icon"></span></button><div class="justify-content-between navbar-collapse collapse" id="basic-navbar-nav"><div class="font-weight-bold navbar-nav"><a href="https://segmentfault.com/" data-rb-event-key="/" class="nav-link">首页</a><a href="https://segmentfault.com/questions" data-rb-event-key="/questions" class="nav-link">问答</a><a href="https://segmentfault.com/blogs" data-rb-event-key="/blogs" class="nav-link">专栏</a><a href="https://segmentfault.com/news" data-rb-event-key="/news" class="nav-link">资讯</a><a href="https://ke.sifou.com/" target="_blank" rel="noreferrer" class="nav-link">课程<i class="ml-1 text-danger fas fa-fire-alt" style="width:0.88rem;vertical-align:text-bottom"></i></a><a href="https://segmentfault.com/events" data-rb-event-key="/events" class="nav-link">活动</a><div class="hover-down dropdown nav-item"><a aria-haspopup="true" aria-expanded="false" id="basic-nav-dropdown" href="https://segmentfault.com/a/1190000015739343#" class="dropdown-toggle nav-link" role="button">发现</a></div></div><form action="https://segmentfault.com/search" class="d-none d-xl-block px-3 header-search___28AtS form-inline"><input type="text" name="q" placeholder="搜索关键字" aria-label="搜索" class="mr-sm-2 w-100 form-control"></form><nav class="p-0 navbar navbar-expand navbar-light"><div class="d-none d-lg-flex mr-2 nav-item"><a href="https://segmentfault.com/user/login" class="btn btn-link">立即登录</a></div><div class="d-none d-lg-flex nav-item"><a href="https://segmentfault.com/user/register" class="btn btn-primary">免费注册</a></div></nav></div></div></nav><div class="d-none d-xl-flex justify-content-center"><div id="OA_holder_2" class="ad-container" style="display:block"><div id="beacon_ff65fdb684" style="position: absolute; left: 0px; top: 0px; visibility: hidden;"><img src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/lg(1).php" width="0" height="0" alt="" style="width: 0px; height: 0px;"></div>
</div></div><div class="article-content container"><nav aria-label="breadcrumb" class="font-size-14 px-0 my-0 mx-4 mx-md-0"><ol class="breadcrumb bg-transparent"><li class="breadcrumb-item"><a href="https://segmentfault.com/">首页</a></li><li class="breadcrumb-item"><a href="https://segmentfault.com/blogs">专栏</a></li><li class="breadcrumb-item"><a href="https://segmentfault.com/t/java/blogs">java</a></li><li class="breadcrumb-item active" aria-current="page">文章详情</li></ol></nav><div class="row"><div class="col-12 col-xl w-0 col"><div class="sticky-wrap sticky-top functional-area-left d-none d-xl-flex justify-content-center pt-5 functional-area-left2"><div role="group" class="align-items-center btn-group-vertical"><button aria-label="点赞" type="button" class="func-btn mainLike  sflex-center shadow-sm rounded-circle main-lg-Like mb-3 btn btn-outline-primary"><i class="far fa-thumbs-up"></i><span class="mainLikeNum ">48</span></button><button aria-label="收藏" type="button" class="func-btn sflex-center rounded-circle mb-2 btn btn-outline-secondary"><i class="far fa-bookmark"></i></button><a class="func-btn sflex-center btn btn-outline-secondary rounded-circle mb-2" href="https://segmentfault.com/a/1190000015739343#comment-area" aria-label="评论"><i class="far fa-comment-alt-lines"></i></a><div class="dropdown"><a href="https://segmentfault.com/a/1190000015739343#" class="func-btn nav-tab-item  rounded-pill btn btn-outline-secondary sflex-center rounded-circle dropdown-toggle" aria-label="分享"><i class="far fa-share-alt"></i></a></div></div></div><canvas hidden="" class="qrcode" height="116" width="116" style="height: 116px; width: 116px;"></canvas><div class="border-0 mb-4 card"><div class="p-lg-30 position-relative card-body"><h1 class="h2 mb-3"><a href="https://segmentfault.com/a/1190000015739343" class="text-body">逐行分析AQS源码(1)——独占锁的获取</a></h1><div class="d-flex align-items-center mb-4"><a href="https://segmentfault.com/u/chiucheng" class="d-flex align-items-center"><picture class="mr-2 d-sm-block d-none"><img src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/3179314346-5f61e47221e07" alt="" class="d-inline-block rounded-circle" width="32"></picture><strong class="align-self-center font-size-14">ChiuCheng</strong></a><time class="text-secondary font-size-14" datetime="2018-07-23T13:57:53.000Z" itemprop="datePublished" style="margin-left:12px">发布于 <!-- -->2018-07-23</time></div><div id="OA_holder_25" class="ad-container" style="display:block"><div id="beacon_286ab6fc20" style="position: absolute; left: 0px; top: 0px; visibility: hidden;"><img src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/lg(2).php" width="0" height="0" alt="" style="width: 0px; height: 0px;"></div>
</div><article class="article fmt article-content ">
<h2 id="item-1">前言</h2>
<p>AQS（AbstractQueuedSynchronizer）是JAVA中众多锁以及并发工具的基础，其底层采用乐观锁，大量使用了CAS操作， 并且在冲突时，采用自旋方式重试，以实现轻量级和高效地获取锁。</p>
<p>AQS虽然被定义为抽象类，但事实上它并不包含任何抽象方法。这是因为AQS是被设计来支持多种用途的，如果定义抽象方法，则子类在继承时必须要覆写所有的抽象方法，这显然是不合理的。所以AQS将一些需要子类覆写的方法都设计成protect方法，将其默认实现为抛出<code>UnsupportedOperationException</code>异常。如果子类使用到这些方法，但是没有覆写，则会抛出异常；如果子类没有使用到这些方法，则不需要做任何操作。</p>
<p>AQS中实现了锁的获取框架，锁的实际获取逻辑交由子类去实现，就锁的获取操作而言，子类必须重写 <code>tryAcquire</code>方法。</p>
<p>本篇我们将以ReentrantLock的公平锁为例来详细看看使用AQS获取独占锁的流程。</p>
<p>本文中的源码基于JDK1.8 。</p>
<p><a href="https://segmentfault.com/a/1190000016058789">系列文章目录</a></p>
<h2 id="item-2">Java并发工具类的三板斧</h2>
<p>在开始看AQS源码之前，我们先来了解以下java并发工具的设计套路，我把它总结成三板斧：</p>
<blockquote>状态，队列，CAS</blockquote>
<p>每当我们学习一个java并发编程工具的时候，我们首先要抓住这三点。</p>
<ul>
<li>
<strong>状态</strong>：一般是一个state属性，它基本是整个工具的核心，通常整个工具都是在<strong>设置和修改状态</strong>，很多方法的操作都依赖于当前状态是什么。由于状态是全局共享的，一般会被设置成volatile类型，以保证其修改的可见性；</li>
<li>
<strong>队列</strong>：队列通常是一个等待的集合，大多数以链表的形式实现。队列采用的是悲观锁的思想，表示当前所等待的资源，状态或者条件短时间内可能无法满足。因此，它会将当前线程包装成某种类型的数据结构，扔到一个等待队列中，当一定条件满足后，再从等待队列中取出。</li>
<li>
<strong>CAS</strong>: CAS操作是最轻量的并发处理，通常我们对于状态的修改都会用到CAS操作，因为状态可能被多个线程同时修改，CAS操作保证了同一个时刻，只有一个线程能修改成功，从而保证了线程安全，CAS操作基本是由Unsafe工具类的<code>compareAndSwapXXX</code>来实现的；CAS采用的是乐观锁的思想，因此常常伴随着自旋，如果发现当前无法成功地执行CAS，则不断重试，直到成功为止，自旋的的表现形式通常是一个死循环<code>for(;;)</code>。</li>
</ul>
<h2 id="item-3">AQS核心实现</h2>
<p>上面我们已经总结了java并发编程的套路，下面我们就以这个套路为切入点来分析AQS的实现。</p>
<h3 id="item-3-1">状态</h3>
<p>首先是找状态。</p>
<p>在AQS中，状态是由state属性来表示的，不出所料，它是volatile类型的：</p>
<div class="widget-codetool" style="display:none;">
        <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark far fa-copy rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="private volatile int state; " title="" data-original-title="复制"></button>
        </div>
        </div><pre class="java hljs"><code class="java" style="word-break: break-word; white-space: initial;"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> state; </code></pre>
<p>该属性的值即表示了锁的状态，state为0表示锁没有被占用，state大于0表示当前已经有线程持有该锁，这里之所以说大于0而不说等于1是因为可能存在可重入的情况。你可以把state变量当做是当前持有该锁的线程数量。</p>
<p>由于本篇我们分析的是独占锁，同一时刻，锁只能被一个线程所持有。通过state变量是否为0，我们可以分辨当前锁是否被占用，但光知道锁是不是被占用是不够的，我们并不知道占用锁的线程是哪一个。在监视器锁中，我们用ObjectMonitor对象的_owner属性记录了当前拥有监视器锁的线程，而在AQS中，我们将通过exclusiveOwnerThread属性：</p>
<div class="widget-codetool" style="display:none;">
        <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark far fa-copy rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="private transient Thread exclusiveOwnerThread; //继承自AbstractOwnableSynchronizer" title="" data-original-title="复制"></button>
        </div>
        </div><pre class="java hljs"><code class="java" style="word-break: break-word; white-space: initial;"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Thread exclusiveOwnerThread; <span class="hljs-comment">//继承自AbstractOwnableSynchronizer</span></code></pre>
<p><code>exclusiveOwnerThread</code>属性的值即为当前持有锁的线程，它就是我们在分析<a href="https://segmentfault.com/a/1190000016016459">监视器锁的原理</a>的时候所说的“铁王座”。</p>
<h3 id="item-3-2">队列</h3>
<p>接着我们来看队列，AQS中，队列的实现是一个双向链表，被称为<code>sync queue</code>，它表示<strong>所有等待锁的线程的集合</strong>，有点类似于我们前面介绍synchronized原理的时候说的<code>wait set</code>。</p>
<p>我们前面说过，在并发编程中使用队列通常是<strong>将当前线程包装成某种类型的数据结构扔到等待队列中</strong>，我们先来看看队列中的每一个节点是怎么个结构：</p>
<div class="widget-codetool" style="display: none;">
        <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark far fa-copy rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="static final class Node {
    /** Marker to indicate a node is waiting in shared mode */
    static final Node SHARED = new Node();
    /** Marker to indicate a node is waiting in exclusive mode */
    static final Node EXCLUSIVE = null;

    /** waitStatus value to indicate thread has cancelled */
    static final int CANCELLED =  1;
    /** waitStatus value to indicate successor&#39;s thread needs unparking */
    static final int SIGNAL    = -1;
    /** waitStatus value to indicate thread is waiting on condition */
    static final int CONDITION = -2;
    /**
     * waitStatus value to indicate the next acquireShared should
     * unconditionally propagate
     */
    static final int PROPAGATE = -3;

    volatile int waitStatus;

    volatile Node prev;

    volatile Node next;

    volatile Thread thread;

    Node nextWaiter;

    final boolean isShared() {
        return nextWaiter == SHARED;
    }

    final Node predecessor() throws NullPointerException {
        Node p = prev;
        if (p == null)
            throw new NullPointerException();
        else
            return p;
    }

    Node() {    // Used to establish initial head or SHARED marker
    }

    Node(Thread thread, Node mode) {     // Used by addWaiter
        this.nextWaiter = mode;
        this.thread = thread;
    }

    Node(Thread thread, int waitStatus) { // Used by Condition
        this.waitStatus = waitStatus;
        this.thread = thread;
    }
}" title="" data-original-title="复制"></button>
        </div>
        </div><pre class="java hljs"><code class="java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>{
    <span class="hljs-comment">/** Marker to indicate a node is waiting in shared mode */</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node SHARED = <span class="hljs-keyword">new</span> Node();
    <span class="hljs-comment">/** Marker to indicate a node is waiting in exclusive mode */</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node EXCLUSIVE = <span class="hljs-keyword">null</span>;

    <span class="hljs-comment">/** waitStatus value to indicate thread has cancelled */</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CANCELLED =  <span class="hljs-number">1</span>;
    <span class="hljs-comment">/** waitStatus value to indicate successor's thread needs unparking */</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIGNAL    = -<span class="hljs-number">1</span>;
    <span class="hljs-comment">/** waitStatus value to indicate thread is waiting on condition */</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CONDITION = -<span class="hljs-number">2</span>;
    <span class="hljs-comment">/**
     * waitStatus value to indicate the next acquireShared should
     * unconditionally propagate
     */</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PROPAGATE = -<span class="hljs-number">3</span>;

    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> waitStatus;

    <span class="hljs-keyword">volatile</span> Node prev;

    <span class="hljs-keyword">volatile</span> Node next;

    <span class="hljs-keyword">volatile</span> Thread thread;

    Node nextWaiter;

    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isShared</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> nextWaiter == SHARED;
    }

    <span class="hljs-function"><span class="hljs-keyword">final</span> Node <span class="hljs-title">predecessor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NullPointerException </span>{
        Node p = prev;
        <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span>)
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();
        <span class="hljs-keyword">else</span>
            <span class="hljs-keyword">return</span> p;
    }

    Node() {    <span class="hljs-comment">// Used to establish initial head or SHARED marker</span>
    }

    Node(Thread thread, Node mode) {     <span class="hljs-comment">// Used by addWaiter</span>
        <span class="hljs-keyword">this</span>.nextWaiter = mode;
        <span class="hljs-keyword">this</span>.thread = thread;
    }

    Node(Thread thread, <span class="hljs-keyword">int</span> waitStatus) { <span class="hljs-comment">// Used by Condition</span>
        <span class="hljs-keyword">this</span>.waitStatus = waitStatus;
        <span class="hljs-keyword">this</span>.thread = thread;
    }
}</code></pre>
<p>这个结构看起来很复杂，其实属性只有4类：</p>
<div class="widget-codetool" style="display:none;">
        <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark far fa-copy rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="// 节点所代表的线程
volatile Thread thread;

// 双向链表，每个节点需要保存自己的前驱节点和后继节点的引用
volatile Node prev;
volatile Node next;

// 线程所处的等待锁的状态，初始化时，该值为0
volatile int waitStatus;
static final int CANCELLED =  1;
static final int SIGNAL    = -1;
static final int CONDITION = -2;
static final int PROPAGATE = -3;

// 该属性用于条件队列或者共享锁
Node nextWaiter;" title="" data-original-title="复制"></button>
        </div>
        </div><pre class="java hljs"><code class="java"><span class="hljs-comment">// 节点所代表的线程</span>
<span class="hljs-keyword">volatile</span> Thread thread;

<span class="hljs-comment">// 双向链表，每个节点需要保存自己的前驱节点和后继节点的引用</span>
<span class="hljs-keyword">volatile</span> Node prev;
<span class="hljs-keyword">volatile</span> Node next;

<span class="hljs-comment">// 线程所处的等待锁的状态，初始化时，该值为0</span>
<span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> waitStatus;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CANCELLED =  <span class="hljs-number">1</span>;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIGNAL    = -<span class="hljs-number">1</span>;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CONDITION = -<span class="hljs-number">2</span>;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PROPAGATE = -<span class="hljs-number">3</span>;

<span class="hljs-comment">// 该属性用于条件队列或者共享锁</span>
Node nextWaiter;</code></pre>
<p>注意，在这个Node类中也有一个状态变量<code>waitStatus</code>，它表示了当前Node所代表的线程的等待锁的状态，在独占锁模式下，我们只需要关注<code>CANCELLED</code> <code>SIGNAL</code>两种状态即可。这里还有一个<code>nextWaiter</code>属性，它在独占锁模式下永远为<code>null</code>，仅仅起到一个标记作用，没有实际意义。这么一分析，这个Node类是不是就简单了好多？&lt;(￣︶￣)&gt;</p>
<p>说完队列中的节点，我们接着说回这个<code>sync queue</code>，AQS是怎么使用这个队列的呢，既然是双向链表，操纵它自然只需要一个头结点和一个尾节点：</p>
<div class="widget-codetool" style="display:none;">
        <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark far fa-copy rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="// 头结点，不代表任何线程，是一个哑结点
private transient volatile Node head;

// 尾节点，每一个请求锁的线程会加到队尾
private transient volatile Node tail;" title="" data-original-title="复制"></button>
        </div>
        </div><pre class="java hljs"><code class="java"><span class="hljs-comment">// 头结点，不代表任何线程，是一个哑结点</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node head;

<span class="hljs-comment">// 尾节点，每一个请求锁的线程会加到队尾</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node tail;</code></pre>
<p>到这里，我们就了解到了这个<code>sync queue</code>的全貌：<br><span class="img-wrap"><img class="lazy entered loaded exited" data-src="/img/remote/1460000016446953?w=1273&amp;h=512" alt="wait queue" title="wait queue" data-ll-status="loaded" src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/1460000016446953"></span></p>
<p>不过这里有一点我们提前说一下，在AQS中的队列是一个CLH队列，它的head节点永远是一个哑结点（dummy node), 它不代表任何线程（某些情况下可以看做是代表了当前持有锁的线程），<strong>因此head所指向的Node的thread属性永远是null</strong>。只有从次头节点往后的所有节点才代表了所有等待锁的线程。也就是说，在当前线程没有抢到锁被包装成Node扔到队列中时，<strong>即使队列是空的，它也会排在第二个</strong>，我们会在它的前面新建一个dummy节点(具体的代码我们在后面分析源码时再详细讲)。为了便于描述，下文中我们把除去head节点的队列称作是等待队列，在这个队列中的节点才代表了所有等待锁的线程：<br><span class="img-wrap"><img class="lazy entered loaded exited" data-src="/img/remote/1460000016446954?w=1279&amp;h=503" alt="dummy head" title="dummy head" data-ll-status="loaded" src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/1460000016446954"></span></p>
<p>在继续往下之前我们再对着上图总结一下Node节点各个参数的含义：</p>
<ul>
<li>
<code>thread</code>：表示当前Node所代表的线程</li>
<li>
<code>waitStatus</code>：表示节点所处的等待状态，共享锁模式下只需关注三种状态：<code>SIGNAL</code> <code>CANCELLED</code> <code>初始态(0)</code>
</li>
<li>
<code>prev</code> <code>next</code>：节点的前驱和后继</li>
<li>
<code>nextWaiter</code>：进作为标记，值永远为null，表示当前处于独占锁模式</li>
</ul>
<h3 id="item-3-3">CAS操作</h3>
<p>前面我们提到过，CAS操作大对数是用来改变状态的，在AQS中也不例外。我们一般在静态代码块中初始化需要CAS操作的属性的偏移量：</p>
<div class="widget-codetool" style="display:none;">
        <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark far fa-copy rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="    private static final Unsafe unsafe = Unsafe.getUnsafe();
    private static final long stateOffset;
    private static final long headOffset;
    private static final long tailOffset;
    private static final long waitStatusOffset;
    private static final long nextOffset;

    static {
        try {
            stateOffset = unsafe.objectFieldOffset
                (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;state&quot;));
            headOffset = unsafe.objectFieldOffset
                (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;head&quot;));
            tailOffset = unsafe.objectFieldOffset
                (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;tail&quot;));
            waitStatusOffset = unsafe.objectFieldOffset
                (Node.class.getDeclaredField(&quot;waitStatus&quot;));
            nextOffset = unsafe.objectFieldOffset
                (Node.class.getDeclaredField(&quot;next&quot;));

        } catch (Exception ex) { throw new Error(ex); }
    }" title="" data-original-title="复制"></button>
        </div>
        </div><pre class="java hljs"><code class="java">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> stateOffset;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> headOffset;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> tailOffset;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> waitStatusOffset;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> nextOffset;

    <span class="hljs-keyword">static</span> {
        <span class="hljs-keyword">try</span> {
            stateOffset = unsafe.objectFieldOffset
                (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="hljs-string">"state"</span>));
            headOffset = unsafe.objectFieldOffset
                (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="hljs-string">"head"</span>));
            tailOffset = unsafe.objectFieldOffset
                (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="hljs-string">"tail"</span>));
            waitStatusOffset = unsafe.objectFieldOffset
                (Node.class.getDeclaredField(<span class="hljs-string">"waitStatus"</span>));
            nextOffset = unsafe.objectFieldOffset
                (Node.class.getDeclaredField(<span class="hljs-string">"next"</span>));

        } <span class="hljs-keyword">catch</span> (Exception ex) { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(ex); }
    }</code></pre>
<p>从这个静态代码块中我们也可以看出，CAS操作主要针对5个属性，包括AQS的3个属性<code>state</code>,<code>head</code>和<code>tail</code>, 以及Node对象的两个属性<code>waitStatus</code>,<code>next</code>。说明这5个属性基本是会被多个线程同时访问的。</p>
<p>定义完属性的偏移量之后，接下来就是CAS操作本身了：</p>
<div class="widget-codetool" style="display:none;">
        <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark far fa-copy rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="protected final boolean compareAndSetState(int expect, int update) {
    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
}
private final boolean compareAndSetHead(Node update) {
    return unsafe.compareAndSwapObject(this, headOffset, null, update);
}
private final boolean compareAndSetTail(Node expect, Node update) {
    return unsafe.compareAndSwapObject(this, tailOffset, expect, update);
}
private static final boolean compareAndSetWaitStatus(Node node, int expect,int update) {
    return unsafe.compareAndSwapInt(node, waitStatusOffset, expect, update);
}
private static final boolean compareAndSetNext(Node node, Node expect, Node update) {
    return unsafe.compareAndSwapObject(node, nextOffset, expect, update);
}" title="" data-original-title="复制"></button>
        </div>
        </div><pre class="java hljs"><code class="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSetState</span><span class="hljs-params">(<span class="hljs-keyword">int</span> expect, <span class="hljs-keyword">int</span> update)</span> </span>{
    <span class="hljs-keyword">return</span> unsafe.compareAndSwapInt(<span class="hljs-keyword">this</span>, stateOffset, expect, update);
}
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSetHead</span><span class="hljs-params">(Node update)</span> </span>{
    <span class="hljs-keyword">return</span> unsafe.compareAndSwapObject(<span class="hljs-keyword">this</span>, headOffset, <span class="hljs-keyword">null</span>, update);
}
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSetTail</span><span class="hljs-params">(Node expect, Node update)</span> </span>{
    <span class="hljs-keyword">return</span> unsafe.compareAndSwapObject(<span class="hljs-keyword">this</span>, tailOffset, expect, update);
}
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSetWaitStatus</span><span class="hljs-params">(Node node, <span class="hljs-keyword">int</span> expect,<span class="hljs-keyword">int</span> update)</span> </span>{
    <span class="hljs-keyword">return</span> unsafe.compareAndSwapInt(node, waitStatusOffset, expect, update);
}
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSetNext</span><span class="hljs-params">(Node node, Node expect, Node update)</span> </span>{
    <span class="hljs-keyword">return</span> unsafe.compareAndSwapObject(node, nextOffset, expect, update);
}</code></pre>
<p>如前面所说，最终CAS操作调用的还是Unsafe类的compareAndSwapXXX方法。</p>
<p>最后就是自旋了，这一点就没有什么好说的了，我们在后面源码分析的时候再详细讲。</p>
<h2 id="item-4">AQS核心属性</h2>
<p>前面我们以java并发编程工具类的“三板斧”为切入点分析了AQS的状态，队列和CAS操作，对这个工具类有了初步的认识。接下来，我们就要开始进入源码分析了。在进入正式的分析之前，我们先来总结下AQS核心属性：</p>
<p>（1）锁相关的属性有两个：</p>
<div class="widget-codetool" style="display:none;">
        <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark far fa-copy rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="private volatile int state; //锁的状态
private transient Thread exclusiveOwnerThread; // 当前持有锁的线程，注意这个属性是从AbstractOwnableSynchronizer继承而来" title="" data-original-title="复制"></button>
        </div>
        </div><pre class="java hljs"><code class="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> state; <span class="hljs-comment">//锁的状态</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Thread exclusiveOwnerThread; <span class="hljs-comment">// 当前持有锁的线程，注意这个属性是从AbstractOwnableSynchronizer继承而来</span></code></pre>
<p>（2）<code>sync queue</code>相关的属性有两个：</p>
<div class="widget-codetool" style="display:none;">
        <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark far fa-copy rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="private transient volatile Node head; // 队头，为dummy node
private transient volatile Node tail; // 队尾，新入队的节点" title="" data-original-title="复制"></button>
        </div>
        </div><pre class="java hljs"><code class="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node head; <span class="hljs-comment">// 队头，为dummy node</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node tail; <span class="hljs-comment">// 队尾，新入队的节点</span></code></pre>
<p>（3）队列中的Node中需要关注的属性有三组：</p>
<div class="widget-codetool" style="display:none;">
        <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark far fa-copy rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="// 节点所代表的线程
volatile Thread thread;

// 双向链表，每个节点需要保存自己的前驱节点和后继节点的引用
volatile Node prev;
volatile Node next;

// 线程所处的等待锁的状态，初始化时，该值为0
volatile int waitStatus;
static final int CANCELLED =  1;
static final int SIGNAL    = -1;" title="" data-original-title="复制"></button>
        </div>
        </div><pre class="java hljs"><code class="java"><span class="hljs-comment">// 节点所代表的线程</span>
<span class="hljs-keyword">volatile</span> Thread thread;

<span class="hljs-comment">// 双向链表，每个节点需要保存自己的前驱节点和后继节点的引用</span>
<span class="hljs-keyword">volatile</span> Node prev;
<span class="hljs-keyword">volatile</span> Node next;

<span class="hljs-comment">// 线程所处的等待锁的状态，初始化时，该值为0</span>
<span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> waitStatus;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CANCELLED =  <span class="hljs-number">1</span>;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIGNAL    = -<span class="hljs-number">1</span>;</code></pre>
<p>拎了这些属性后，我们下面分析源码就容易很多了。</p>
<h2 id="item-5">Example: FairSync in ReentrantLock</h2>
<p>前面已经提到, AQS大多数情况下都是通过继承来使用的, 子类通过覆写 <code>tryAcquire</code> 来实现自己的获取锁的逻辑，我们这里以ReentrantLock为例来说明锁的获取流程。</p>
<p>值得注意的是, ReentrantLock有 <code>公平锁</code> 和 <code>非公平锁</code> 两种实现, 默认实现为非公平锁, 这体现在它的构造函数中:</p>
<div class="widget-codetool" style="display:none;">
        <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark far fa-copy rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="public class ReentrantLock implements Lock, java.io.Serializable {
    /** Synchronizer providing all implementation mechanics */
    private final Sync sync;
    
    /**
     * Base of synchronization control for this lock. Subclassed
     * into fair and nonfair versions below. Uses AQS state to
     * represent the number of holds on the lock.
     */
    abstract static class Sync extends AbstractQueuedSynchronizer {
        ...
    }
    
    /**
     * Sync object for non-fair locks
     */
    static final class NonfairSync extends Sync{
        ...
    }
    
    /**
     * Sync object for fair locks
     */
    static final class FairSync extends Sync {
        ...
    }
    
    /**
     * Creates an instance of {@code ReentrantLock}.
     * This is equivalent to using {@code ReentrantLock(false)}.
     */
    public ReentrantLock() {
        sync = new NonfairSync();
    }

    /**
     * Creates an instance of {@code ReentrantLock} with the
     * given fairness policy.
     *
     * @param fair {@code true} if this lock should use a fair ordering policy
     */
    public ReentrantLock(boolean fair) {
        sync = fair ? new FairSync() : new NonfairSync();
    }
    
    // 获取锁
    public void lock() {
        sync.lock();
    }
    
    ...
}" title="" data-original-title="复制"></button>
        </div>
        </div><pre class="java hljs"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReentrantLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>{
    <span class="hljs-comment">/** Synchronizer providing all implementation mechanics */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sync sync;
    
    <span class="hljs-comment">/**
     * Base of synchronization control for this lock. Subclassed
     * into fair and nonfair versions below. Uses AQS state to
     * represent the number of holds on the lock.
     */</span>
    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>{
        ...
    }
    
    <span class="hljs-comment">/**
     * Sync object for non-fair locks
     */</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span></span>{
        ...
    }
    
    <span class="hljs-comment">/**
     * Sync object for fair locks
     */</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>{
        ...
    }
    
    <span class="hljs-comment">/**
     * Creates an instance of {<span class="hljs-doctag">@code</span> ReentrantLock}.
     * This is equivalent to using {<span class="hljs-doctag">@code</span> ReentrantLock(false)}.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantLock</span><span class="hljs-params">()</span> </span>{
        sync = <span class="hljs-keyword">new</span> NonfairSync();
    }

    <span class="hljs-comment">/**
     * Creates an instance of {<span class="hljs-doctag">@code</span> ReentrantLock} with the
     * given fairness policy.
     *
     * <span class="hljs-doctag">@param</span> fair {<span class="hljs-doctag">@code</span> true} if this lock should use a fair ordering policy
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantLock</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> fair)</span> </span>{
        sync = fair ? <span class="hljs-keyword">new</span> FairSync() : <span class="hljs-keyword">new</span> NonfairSync();
    }
    
    <span class="hljs-comment">// 获取锁</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>{
        sync.lock();
    }
    
    ...
}</code></pre>
<p>可以看出, <code>FairSync</code> 继承自 <code>Sync</code>, 而<code>Sync</code>继承自 <code>AQS</code>, ReentrantLock获取锁的逻辑是直接调用了 <code>FairSync</code> 或者 <code>NonfairSync</code>的逻辑.</p>
<p>好了, <code>ReentrantLock</code> 就简单说到这里, 以后我们有机会再详细讲, 这里直接以 <code>FairLock</code> 为例, 来逐行分析锁的获取:</p>
<div class="widget-codetool" style="display:none;">
        <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark far fa-copy rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="static final class FairSync extends Sync {
    private static final long serialVersionUID = -3000897897090466540L;
    //获取锁
    final void lock() {
        acquire(1);
    }
    ...
}" title="" data-original-title="复制"></button>
        </div>
        </div><pre class="java hljs"><code class="java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">3000897897090466540L</span>;
    <span class="hljs-comment">//获取锁</span>
    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>{
        acquire(<span class="hljs-number">1</span>);
    }
    ...
}</code></pre>
<p>lock 方法调用的 <code>acquire</code>方法来自父类AQS。 </p>
<p>这里首先给出完整的获取锁的流程图, 再逐行分析代码, 因为看源码的时候, 代码会在函数或者循环中来回跳转，读者可以对照以下流程图, 就不容易被绕晕了. </p>
<p><span class="img-wrap"><img class="lazy entered loaded exited" data-src="/img/remote/1460000015739346?w=783&amp;h=1043" alt="ReentrantLock 公平锁获取流程图" title="ReentrantLock 公平锁获取流程图" data-ll-status="loaded" src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/1460000015739346"></span></p>
<h3 id="item-5-4">acquire</h3>
<p>acquire 定义在AQS类中，描述了获取锁的流程</p>
<div class="widget-codetool" style="display:none;">
        <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark far fa-copy rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}" title="" data-original-title="复制"></button>
        </div>
        </div><pre class="java hljs"><code class="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>{
    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}</code></pre>
<p>可以看出, 该方法中涉及了四个方法的调用:</p>
<p><strong>（1）tryAcquire(arg)</strong></p>
<p>该方法由继承AQS的子类实现, 为获取锁的具体逻辑。</p>
<p><strong>（2）addWaiter(Node mode)</strong>  </p>
<p>该方法由AQS实现, 负责在获取锁失败后调用, 将当前请求锁的线程包装成Node扔到sync queue中去，并返回这个Node。</p>
<p><strong>（3）acquireQueued(final Node node, int arg)</strong>   </p>
<p>该方法由AQS实现,这个方法比较复杂, 主要对上面刚加入队列的Node不断尝试以下两种操作之一:</p>
<ul>
<li>在前驱节点就是head节点的时候,继续尝试获取锁</li>
<li>将当前线程挂起,使CPU不再调度它</li>
</ul>
<p><strong>（4）selfInterrupt</strong>  </p>
<p>该方法由AQS实现, 用于中断当前线程。由于在整个抢锁过程中，我们都是不响应中断的。那如果在抢锁的过程中发生了中断怎么办呢，总不能假装没看见呀。AQS的做法简单的记录有没有有发生过中断，如果返回的时候发现曾经发生过中断，则在退出<code>acquire</code>方法之前，就调用<code>selfInterrupt</code>自我中断一下，就好像将这个发生在抢锁过程中的中断“推迟”到抢锁结束以后再发生一样。</p>
<p>从上面的简单介绍中可以看出，除了获取锁的逻辑 <code>tryAcquire(arg)</code>由子类实现外, 其余方法均由AQS实现。</p>
<p>接下来我们重点来看 <code>FairSync</code> 所实现的获取锁的逻辑:</p>
<h3 id="item-5-5">tryAcquire</h3>
<p><code>tryAcquire</code> 获取锁的逻辑其实很简单——判断当前锁有没有被占用：</p>
<ol>
<li>如果锁没有被占用, 尝试以公平的方式获取锁</li>
<li>如果锁已经被占用, 检查是不是锁重入</li>
</ol>
<p>获取锁成功返回<code>true</code>, 失败则返回<code>false</code></p>
<div class="widget-codetool" style="display:none;">
        <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark far fa-copy rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="protected final boolean tryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    // 首先获取当前锁的状态
    int c = getState(); 
    
    // c=0 说明当前锁是avaiable的, 没有被任何线程占用, 可以尝试获取
    // 因为是实现公平锁, 所以在抢占之前首先看看队列中有没有排在自己前面的Node
    // 如果没有人在排队, 则通过CAS方式获取锁, 就可以直接退出了
    if (c == 0) {
        if (!hasQueuedPredecessors() 
        /* 为了阅读方便, hasQueuedPredecessors源码就直接贴在这里了, 这个方法的本质实际上是检测自己是不是head节点的后继节点，即处在阻塞队列第一位的节点
            public final boolean hasQueuedPredecessors() {
                Node t = tail; 
                Node h = head;
                Node s;
                return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());
            }
        */
        &amp;&amp; compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current); // 将当前线程设置为占用锁的线程
            return true;
        }
    }
    
    // 如果 c&gt;0 说明锁已经被占用了
    // 对于可重入锁, 这个时候检查占用锁的线程是不是就是当前线程,是的话,说明已经拿到了锁, 直接重入就行
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc &lt; 0)
            throw new Error(&quot;Maximum lock count exceeded&quot;);
        setState(nextc);
        /* setState方法如下：
        protected final void setState(int newState) {
            state = newState;
        }
        */
        return true;
    }
    
    // 到这里说明有人占用了锁, 并且占用锁的不是当前线程, 则获取锁失败
    return false;
}" title="" data-original-title="复制"></button>
        </div>
        </div><pre class="java hljs"><code class="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>{
    <span class="hljs-keyword">final</span> Thread current = Thread.currentThread();
    <span class="hljs-comment">// 首先获取当前锁的状态</span>
    <span class="hljs-keyword">int</span> c = getState(); 
    
    <span class="hljs-comment">// c=0 说明当前锁是avaiable的, 没有被任何线程占用, 可以尝试获取</span>
    <span class="hljs-comment">// 因为是实现公平锁, 所以在抢占之前首先看看队列中有没有排在自己前面的Node</span>
    <span class="hljs-comment">// 如果没有人在排队, 则通过CAS方式获取锁, 就可以直接退出了</span>
    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() 
        <span class="hljs-comment">/* 为了阅读方便, hasQueuedPredecessors源码就直接贴在这里了, 这个方法的本质实际上是检测自己是不是head节点的后继节点，即处在阻塞队列第一位的节点
            public final boolean hasQueuedPredecessors() {
                Node t = tail; 
                Node h = head;
                Node s;
                return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());
            }
        */</span>
        &amp;&amp; compareAndSetState(<span class="hljs-number">0</span>, acquires)) {
            setExclusiveOwnerThread(current); <span class="hljs-comment">// 将当前线程设置为占用锁的线程</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        }
    }
    
    <span class="hljs-comment">// 如果 c&gt;0 说明锁已经被占用了</span>
    <span class="hljs-comment">// 对于可重入锁, 这个时候检查占用锁的线程是不是就是当前线程,是的话,说明已经拿到了锁, 直接重入就行</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) {
        <span class="hljs-keyword">int</span> nextc = c + acquires;
        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">"Maximum lock count exceeded"</span>);
        setState(nextc);
        <span class="hljs-comment">/* setState方法如下：
        protected final void setState(int newState) {
            state = newState;
        }
        */</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }
    
    <span class="hljs-comment">// 到这里说明有人占用了锁, 并且占用锁的不是当前线程, 则获取锁失败</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
}</code></pre>
<p>从这里可以看出，获取锁其实主要就是干一件事：</p>
<blockquote>将state的状态通过CAS操作由0改写成1</blockquote>
<p>由于是CAS操作，必然是只有一个线程能执行成功。则执行成功的线程即获取了锁，在这之后，才有权利将<code>exclusiveOwnerThread</code>的值设成自己，从而“坐上铁王座”。<br>另外对于可重入锁，如果当前线程已经是获取了锁的线程了，它还要注意增加锁的重入次数。</p>
<p>值得一提的是，这里修改state状态的操作，一个用了CAS方法<code>compareAndSetState</code>，一个用了普通的<code>setState</code>方法。这是因为用CAS操作时，当前线程还没有获得锁，所以可能存在多线程同时在竞争锁的情况；而调用setState方法时，是在当前线程已经是持有锁的情况下，因此对state的修改是安全的，只需要普通的方法就可以了。</p>
<p>因此，在多线程条件下看源码时，我们一定要时刻在心中问自己：</p>
<blockquote>这段代码是否是线程安全的？同一时刻是否可能有多个线程在执行这行代码?</blockquote>
<h3 id="item-5-6">addWaiter</h3>
<p>如果执行到此方法, 说明前面尝试获取锁的<code>tryAcquire</code>已经失败了, 既然获取锁已经失败了, 就要将当前线程包装成Node，加到等待锁的队列中去, 因为是FIFO队列, 所以自然是直接加在队尾。<br>方法调用为：</p>
<div class="widget-codetool" style="display:none;">
        <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark far fa-copy rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="addWaiter(Node.EXCLUSIVE)" title="" data-original-title="复制"></button>
        </div>
        </div><pre class="java hljs"><code class="java" style="word-break: break-word; white-space: initial;">addWaiter(Node.EXCLUSIVE)</code></pre>
<div class="widget-codetool" style="display:none;">
        <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark far fa-copy rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="private Node addWaiter(Node mode) {
    Node node = new Node(Thread.currentThread(), mode); //将当前线程包装成Node
    // 这里我们用注释的形式把Node的构造函数贴出来
    // 因为传入的mode值为Node.EXCLUSIVE，所以节点的nextWaiter属性被设为null
    /*
        static final Node EXCLUSIVE = null;
        
        Node(Thread thread, Node mode) {     // Used by addWaiter
            this.nextWaiter = mode;
            this.thread = thread;
        }
    */
    Node pred = tail;
    // 如果队列不为空, 则用CAS方式将当前节点设为尾节点
    if (pred != null) {
        node.prev = pred;
        if (compareAndSetTail(pred, node)) {
            pred.next = node;
            return node;
        }
    }
    
    // 代码会执行到这里, 只有两种情况:
    //    1. 队列为空
    //    2. CAS失败
    // 注意, 这里是并发条件下, 所以什么都有可能发生, 尤其注意CAS失败后也会来到这里
    enq(node); //将节点插入队列
    return node;
}" title="" data-original-title="复制"></button>
        </div>
        </div><pre class="java hljs"><code class="java"><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">addWaiter</span><span class="hljs-params">(Node mode)</span> </span>{
    Node node = <span class="hljs-keyword">new</span> Node(Thread.currentThread(), mode); <span class="hljs-comment">//将当前线程包装成Node</span>
    <span class="hljs-comment">// 这里我们用注释的形式把Node的构造函数贴出来</span>
    <span class="hljs-comment">// 因为传入的mode值为Node.EXCLUSIVE，所以节点的nextWaiter属性被设为null</span>
    <span class="hljs-comment">/*
        static final Node EXCLUSIVE = null;
        
        Node(Thread thread, Node mode) {     // Used by addWaiter
            this.nextWaiter = mode;
            this.thread = thread;
        }
    */</span>
    Node pred = tail;
    <span class="hljs-comment">// 如果队列不为空, 则用CAS方式将当前节点设为尾节点</span>
    <span class="hljs-keyword">if</span> (pred != <span class="hljs-keyword">null</span>) {
        node.prev = pred;
        <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) {
            pred.next = node;
            <span class="hljs-keyword">return</span> node;
        }
    }
    
    <span class="hljs-comment">// 代码会执行到这里, 只有两种情况:</span>
    <span class="hljs-comment">//    1. 队列为空</span>
    <span class="hljs-comment">//    2. CAS失败</span>
    <span class="hljs-comment">// 注意, 这里是并发条件下, 所以什么都有可能发生, 尤其注意CAS失败后也会来到这里</span>
    enq(node); <span class="hljs-comment">//将节点插入队列</span>
    <span class="hljs-keyword">return</span> node;
}</code></pre>
<p>可见，每一个处于独占锁模式下的节点，它的<code>nextWaiter</code>一定是null。<br>在这个方法中，我们首先会尝试直接入队，但是因为目前是在并发条件下，所以有可能同一时刻，有多个线程都在尝试入队，导致<code>compareAndSetTail(pred, node)</code>操作失败——因为有可能其他线程已经成为了新的尾节点，导致尾节点不再是我们之前看到的那个<code>pred</code>了。</p>
<p>如果入队失败了，接下来我们就需要调用enq(node)方法，在该方法中我们将通过<code>自旋+CAS</code>的方式，确保当前节点入队。</p>
<h3 id="item-5-7">enq</h3>
<p>能执行到这个方法，说明当前线程获取锁已经失败了，我们已经把它包装成一个Node,准备把它扔到等待队列中去，但是在这一步又失败了。这个失败的原因可能是以下两种之一：</p>
<ol>
<li>等待队列现在是空的，没有线程在等待。</li>
<li><strong>其他线程在当前线程入队的过程中率先完成了入队，导致尾节点的值已经改变了，CAS操作失败。</strong></li>
</ol>
<p>在该方法中, 我们使用了死循环, 即以自旋方式将节点插入队列，如果失败则不停的尝试, 直到成功为止, 另外, 该方法也负责在队列为空时, 初始化队列，这也说明，队列是延时初始化的(lazily initialized)：</p>
<div class="widget-codetool" style="display:none;">
        <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark far fa-copy rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="private Node enq(final Node node) {
    for (;;) {
        Node t = tail;
        // 如果是空队列, 首先进行初始化
        // 这里也可以看出, 队列不是在构造的时候初始化的, 而是延迟到需要用的时候再初始化, 以提升性能
        if (t == null) { 
            // 注意，初始化时使用new Node()方法新建了一个dummy节点
            if (compareAndSetHead(new Node()))
                tail = head; // 这里仅仅是将尾节点指向dummy节点，并没有返回
        } else {
        // 到这里说明队列已经不是空的了, 这个时候再继续尝试将节点加到队尾
            node.prev = t;
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}" title="" data-original-title="复制"></button>
        </div>
        </div><pre class="java hljs"><code class="java"><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> </span>{
    <span class="hljs-keyword">for</span> (;;) {
        Node t = tail;
        <span class="hljs-comment">// 如果是空队列, 首先进行初始化</span>
        <span class="hljs-comment">// 这里也可以看出, 队列不是在构造的时候初始化的, 而是延迟到需要用的时候再初始化, 以提升性能</span>
        <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) { 
            <span class="hljs-comment">// 注意，初始化时使用new Node()方法新建了一个dummy节点</span>
            <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> Node()))
                tail = head; <span class="hljs-comment">// 这里仅仅是将尾节点指向dummy节点，并没有返回</span>
        } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 到这里说明队列已经不是空的了, 这个时候再继续尝试将节点加到队尾</span>
            node.prev = t;
            <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) {
                t.next = node;
                <span class="hljs-keyword">return</span> t;
            }
        }
    }
}</code></pre>
<p>这里尤其要注意的是，当队列为空时，我们初始化队列并没有使用当前传进来的节点，而是：  <br><strong><em>新建了一个空节点！！！</em></strong>  <br><strong><em>新建了一个空节点！！！</em></strong>  <br><strong><em>新建了一个空节点！！！</em></strong>  </p>
<p>在新建完空的头节点之后，我们<strong>并没有立即返回</strong>，而是将尾节点指向当前的头节点，然后进入下一轮循环。<br>在下一轮循环中，尾节点已经不为null了，此时再将我们包装了当前线程的Node加到这个空节点后面。</p>
<p>这就意味着，在这个等待队列中，头结点是一个“哑节点”，它不代表任何等待的线程。  <br><strong><em>head节点不代表任何线程，它就是一个空节点！！！</em></strong>  <br><strong><em>head节点不代表任何线程，它就是一个空节点！！！</em></strong>  <br><strong><em>head节点不代表任何线程，它就是一个空节点！！！</em></strong></p>
<h3 id="item-5-8">尾分叉</h3>
<p>在继续往下之前，我们先分析enq方法中一个比较有趣的现象，我把它叫做尾分叉。我们着重看将当前节点设置成尾节点的操作：</p>
<div class="widget-codetool" style="display:none;">
        <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark far fa-copy rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="} else {
// 到这里说明队列已经不是空的了, 这个时候再继续尝试将节点加到队尾
    node.prev = t;
    if (compareAndSetTail(t, node)) {
        t.next = node;
        return t;
    }
}" title="" data-original-title="复制"></button>
        </div>
        </div><pre class="java hljs"><code class="java">} <span class="hljs-keyword">else</span> {
<span class="hljs-comment">// 到这里说明队列已经不是空的了, 这个时候再继续尝试将节点加到队尾</span>
    node.prev = t;
    <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) {
        t.next = node;
        <span class="hljs-keyword">return</span> t;
    }
}</code></pre>
<p>与将大象放到冰箱里需要三步一样，将一个节点node添加到<code>sync queue</code>的末尾也需要三步：</p>
<ol>
<li>设置node的前驱节点为当前的尾节点：<code>node.prev = t</code>
</li>
<li>修改<code>tail</code>属性，使它指向当前节点</li>
<li>修改原来的尾节点，使它的next指向当前节点</li>
</ol>
<p><span class="img-wrap"><img class="lazy entered exited" data-src="/img/remote/1460000016446955?w=1261&amp;h=522" alt="set tail" title="set tail"></span></p>
<p>但是需要注意的，这里的三步并不是一个原子操作，第一步很容易成功；而第二步由于是一个CAS操作，在并发条件下有可能失败，第三步只有在第二步成功的条件下才执行。这里的CAS保证了同一时刻只有一个节点能成为尾节点，其他节点将失败，失败后将回到for循环中继续重试。</p>
<p>所以，当有大量的线程在同时入队的时候，同一时刻，只有一个线程能完整地完成这三步，<strong>而其他线程只能完成第一步</strong>，于是就出现了尾分叉：<br><span class="img-wrap"><img class="lazy entered exited" data-src="/img/remote/1460000016446956?w=1018&amp;h=487" alt="尾分叉" title="尾分叉"></span></p>
<p>注意，这里第三步是在第二步执行成功后才执行的，这就意味着，有可能即使我们已经完成了第二步，将新的节点设置成了尾节点，<strong>此时原来旧的尾节点的next值可能还是<code>null</code></strong>(因为还没有来的及执行第三步)，所以如果此时有线程恰巧从头节点开始向后遍历整个链表，则它是遍历不到新加进来的尾节点的，但是这显然是不合理的，因为现在的tail已经指向了新的尾节点。  <br>另一方面，当我们完成了第二步之后，第一步一定是完成了的，所以如果我们从尾节点开始向前遍历，已经可以遍历到所有的节点。这也就是为什么我们在AQS相关的源码中，有时候常常会出现从尾节点开始逆向遍历链表——因为一个节点要能入队，则它的prev属性一定是有值的，但是它的next属性可能暂时还没有值。</p>
<p>至于那些“分叉”的入队失败的其他节点，在下一轮的循环中，它们的prev属性会重新指向新的尾节点，继续尝试新的CAS操作，最终，所有节点都会通过自旋不断的尝试入队，直到成功为止。</p>
<h3 id="item-5-9">addWaiter总结</h3>
<p>至此，我们就完成了addWaiter(Node.EXCLUSIVE)方法的完整的分析，该方法并不设计到任何关于锁的操作，它就是解决了并发条件下的节点入队问题。具体来说就是该方法保证了将当前线程包装成Node节点加入到等待队列的队尾，如果队列为空，则会新建一个哑节点作为头节点，再将当前节点接在头节点的后面。</p>
<p>addWaiter(Node.EXCLUSIVE)方法最终返回了代表了当前线程的Node节点，在返回的那一刻，这个节点必然是当时的<code>sync queue</code>的尾节点。</p>
<p>不过值得注意的是，enq方法也是有返回值（虽然这里我们并没有使用它的返回值），但是它返回的是node节点的前驱节点，这个返回值虽然在addWaiter方法中并没有使用，但是在其他地方会被用到。</p>
<p>我们再回到获取锁的逻辑中：</p>
<div class="widget-codetool" style="display:none;">
        <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark far fa-copy rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}" title="" data-original-title="复制"></button>
        </div>
        </div><pre class="java hljs"><code class="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>{
    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}</code></pre>
<p>当addWaiter(Node.EXCLUSIVE)执行完毕后，节点现在已经被成功添加到<code>sync queue</code>中了，接下来将执行acquireQueued方法。</p>
<h3 id="item-5-10">acquireQueued</h3>
<p>该方法是最复杂的一个方法, 也是最难啃的骨头, 看代码之前首先简单的说明几点:  </p>
<p>(1) 能执行到该方法, 说明<code>addWaiter</code> 方法已经成功将包装了当前Thread的节点添加到了等待队列的队尾  <br>(2) 该方法中将再次尝试去获取锁  <br>(3) 在再次尝试获取锁失败后, 判断是否需要把当前线程挂起</p>
<p><strong>为什么前面获取锁失败了, 这里还要再次尝试获取锁呢?</strong>  <br>首先, 这里再次尝试获取锁是<strong>基于一定的条件</strong>的,即:</p>
<blockquote>当前节点的前驱节点就是HEAD节点</blockquote>
<p>因为我们知道，head节点就是个哑节点，它不代表任何线程，或者代表了持有锁的线程，如果当前节点的前驱节点就是head节点，那就说明当前节点已经是排在整个等待队列最前面的了。</p>
<div class="widget-codetool" style="display:none;">
        <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark far fa-copy rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();
            // 在当前节点的前驱就是HEAD节点时, 再次尝试获取锁
            if (p == head &amp;&amp; tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return interrupted;
            }
            //在获取锁失败后, 判断是否需要把当前线程挂起
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}" title="" data-original-title="复制"></button>
        </div>
        </div><pre class="java hljs"><code class="java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-keyword">int</span> arg)</span> </span>{
    <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">for</span> (;;) {
            <span class="hljs-keyword">final</span> Node p = node.predecessor();
            <span class="hljs-comment">// 在当前节点的前驱就是HEAD节点时, 再次尝试获取锁</span>
            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) {
                setHead(node);
                p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span>
                failed = <span class="hljs-keyword">false</span>;
                <span class="hljs-keyword">return</span> interrupted;
            }
            <span class="hljs-comment">//在获取锁失败后, 判断是否需要把当前线程挂起</span>
            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())
                interrupted = <span class="hljs-keyword">true</span>;
        }
    } <span class="hljs-keyword">finally</span> {
        <span class="hljs-keyword">if</span> (failed)
            cancelAcquire(node);
    }
}</code></pre>
<p>注意，这里又来了个自旋操作，我们一段段来看：</p>
<div class="widget-codetool" style="display:none;">
        <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark far fa-copy rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="final Node p = node.predecessor();
// 在当前节点的前驱就是HEAD节点时, 再次尝试获取锁
if (p == head &amp;&amp; tryAcquire(arg)) {
    setHead(node);
    p.next = null; // help GC
    failed = false;
    return interrupted;
}" title="" data-original-title="复制"></button>
        </div>
        </div><pre class="java hljs"><code class="java"><span class="hljs-keyword">final</span> Node p = node.predecessor();
<span class="hljs-comment">// 在当前节点的前驱就是HEAD节点时, 再次尝试获取锁</span>
<span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) {
    setHead(node);
    p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span>
    failed = <span class="hljs-keyword">false</span>;
    <span class="hljs-keyword">return</span> interrupted;
}</code></pre>
<p>首先我们获取尾节点的前驱节点（因为上一步中返回的就是尾节点，并且这个节点就是代表了当前线程的Node）。<br>如果前驱节点就是head节点，那说明当前线程已经排在了队列的最前面，所以这里我们再试着去获取锁。如果这一次获取成功了，即tryAcquire方法返回了true, 则我们将进入if代码块，调用<code>setHead</code>方法：</p>
<div class="widget-codetool" style="display:none;">
        <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark far fa-copy rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="private void setHead(Node node) {
    head = node;
    node.thread = null;
    node.prev = null;
}" title="" data-original-title="复制"></button>
        </div>
        </div><pre class="java hljs"><code class="java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHead</span><span class="hljs-params">(Node node)</span> </span>{
    head = node;
    node.thread = <span class="hljs-keyword">null</span>;
    node.prev = <span class="hljs-keyword">null</span>;
}</code></pre>
<p>这个方法将head指向传进来的node,并且将node的thread和prev属性置为null, 如下图所示：<br><span class="img-wrap"><img class="lazy entered exited" data-src="/img/remote/1460000016446957?w=686&amp;h=508" alt="setHead" title="setHead"></span></p>
<p>可以看出，这个方法的本质是丢弃原来的head，将head指向已经获得了锁的node。但是接着又将该node的thread属性置为null了，<strong>这某种意义上导致了这个新的head节点又成为了一个哑节点，它不代表任何线程</strong>。为什么要这样做呢，因为在tryAcquire调用成功后，exclusiveOwnerThread属性就已经记录了当前获取锁的线程了，此处没有必要再记录。<strong>这某种程度上就是将当前线程从等待队列里面拿出来了，是一个变相的出队操作。</strong></p>
<p>还有另外一个特点是，这个setHead方法只是个普通方法，并没有像之前enq方法中那样采用compareAndSetHead方法，这是为什么呢？ 同我们之前分析setState方法一样：</p>
<p>因为这里不会产生竞争！</p>
<p>在enq方法中，当我们设置头节点的时候，是新建一个哑节点并将它作为头节点，这个时候，可能多个线程都在执行这一步，因此我们需要通过CAS操作保证只有一个线程能成功。  <br>在acquireQueued方法里，由于我们在调用到setHead的时，已经通过tryAcquire方法获得了锁，这意味着：</p>
<ol>
<li>此时没有其他线程在创建新的头节点——因为很明显此时队列并不是空的，不会执行到创建头节点的代码</li>
<li>此时能执行setHead的只有一个线程——因为要执行到setHead, 必然是tryAcquire已经返回了true, 而同一时刻，只有一个线程能获取到锁</li>
</ol>
<p>综上，在整个if语句内的代码即使不加锁，也是线程安全的，不需要采用CAS操作。</p>
<p>接下来我们再来看看另一种情况，即<code>p == head &amp;&amp; tryAcquire(arg)</code>返回了false，此时我们需要判断是否需要将当前线程挂起：</p>
<h3 id="item-5-11">shouldParkAfterFailedAcquire</h3>
<p>从函数名也可以看出, 该方法用于决定在获取锁失败后, 是否将线程挂起.</p>
<p>决定的依据就是<strong>前驱节点的</strong><code>waitStatus</code>值。</p>
<p>（有没发现一直到现在，前面的分析中我们都没有用到<code>waitStatus</code>的值，终于在这里要用到了）</p>
<p>我们先来回顾一下waitStatus有哪些状态值：</p>
<div class="widget-codetool" style="display:none;">
        <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark far fa-copy rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="static final int CANCELLED =  1;
static final int SIGNAL    = -1;
static final int CONDITION = -2;
static final int PROPAGATE = -3;" title="" data-original-title="复制"></button>
        </div>
        </div><pre class="java hljs"><code class="java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CANCELLED =  <span class="hljs-number">1</span>;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIGNAL    = -<span class="hljs-number">1</span>;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CONDITION = -<span class="hljs-number">2</span>;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PROPAGATE = -<span class="hljs-number">3</span>;</code></pre>
<p>一共有四种状态，但是我们在开篇的时候就说过，在独占锁锁的获取操作中，我们只用到了其中的两个——<code>CANCELLED</code>和<code>SIGNAL</code>。  <br>当然，前面我们在创建节点的时候并没有给waitStatus赋值，因此每一个节点最开始的时候waitStatus的值都被初始化为0，即不属于上面任何一种状态。</p>
<p>那么<code>CANCELLED</code>和<code>SIGNAL</code>代表什么意思呢？</p>
<p><code>CANCELLED</code>状态很好理解，它表示Node所代表的当前线程已经取消了排队，即放弃获取锁了。  </p>
<p><code>SIGNAL</code>这个状态就有点意思了，它不是表征当前节点的状态，而是当前节点的下一个节点的状态。  <br>当一个节点的waitStatus被置为<code>SIGNAL</code>，就说明它的下一个节点（即它的后继节点）已经被挂起了（或者马上就要被挂起了），因此在当前节点释放了锁或者放弃获取锁时，如果它的waitStatus属性为<code>SIGNAL</code>，它还要完成一个额外的操作——唤醒它的后继节点。</p>
<p>有意思的是，<code>SIGNAL</code>这个状态的设置常常不是节点自己给自己设的，而是后继节点设置的，这里给大家打个比方：</p>
<p>比如说出去吃饭，在人多的时候经常要排队取号，你取到了8号，前面还有7个人在等着进去，你就和排在你前面的7号讲“哥们，我现在排在你后面，队伍这么长，估计一时半会儿也轮不到我，我去那边打个盹，一会轮到你进去了(release)或者你不想等了(cancel), 麻烦你都叫醒我”，说完，你就把他的waitStatus值设成了<code>SIGNAL</code>。</p>
<p>换个角度讲，当我们决定要将一个线程挂起之前，首先要确保自己的前驱节点的waitStatus为<code>SIGNAL</code>，这就相当于给自己设一个闹钟再去睡，这个闹钟会在恰当的时候叫醒自己，否则，如果一直没有人来叫醒自己，自己可能就一直睡到天荒地老了。</p>
<p>理解了<code>CANCELLED</code>和<code>SIGNAL</code>这两个状态的含义后，我们再来看看shouldParkAfterFailedAcquire是怎么用的：</p>
<div class="widget-codetool" style="display:none;">
        <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark far fa-copy rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    int ws = pred.waitStatus; // 获得前驱节点的ws
    if (ws == Node.SIGNAL)
        // 前驱节点的状态已经是SIGNAL了，说明闹钟已经设了，可以直接睡了
        return true;
    if (ws &gt; 0) {
        // 当前节点的 ws &gt; 0, 则为 Node.CANCELLED 说明前驱节点已经取消了等待锁(由于超时或者中断等原因)
        // 既然前驱节点不等了, 那就继续往前找, 直到找到一个还在等待锁的节点
        // 然后我们跨过这些不等待锁的节点, 直接排在等待锁的节点的后面 (是不是很开心!!!)
        do {
            node.prev = pred = pred.prev;
        } while (pred.waitStatus &gt; 0);
        pred.next = node;
    } else {
        // 前驱节点的状态既不是SIGNAL，也不是CANCELLED
        // 用CAS设置前驱节点的ws为 Node.SIGNAL，给自己定一个闹钟
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    }
    return false;
}" title="" data-original-title="复制"></button>
        </div>
        </div><pre class="java hljs"><code class="java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> </span>{
    <span class="hljs-keyword">int</span> ws = pred.waitStatus; <span class="hljs-comment">// 获得前驱节点的ws</span>
    <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)
        <span class="hljs-comment">// 前驱节点的状态已经是SIGNAL了，说明闹钟已经设了，可以直接睡了</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-comment">// 当前节点的 ws &gt; 0, 则为 Node.CANCELLED 说明前驱节点已经取消了等待锁(由于超时或者中断等原因)</span>
        <span class="hljs-comment">// 既然前驱节点不等了, 那就继续往前找, 直到找到一个还在等待锁的节点</span>
        <span class="hljs-comment">// 然后我们跨过这些不等待锁的节点, 直接排在等待锁的节点的后面 (是不是很开心!!!)</span>
        <span class="hljs-keyword">do</span> {
            node.prev = pred = pred.prev;
        } <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);
        pred.next = node;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 前驱节点的状态既不是SIGNAL，也不是CANCELLED</span>
        <span class="hljs-comment">// 用CAS设置前驱节点的ws为 Node.SIGNAL，给自己定一个闹钟</span>
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
}</code></pre>
<p>可以看出，shouldParkAfterFailedAcquire所做的事情无外乎：</p>
<ul>
<li>如果为前驱节点的<code>waitStatus</code>值为 <code>Node.SIGNAL</code> 则直接返回 <code>true</code>
</li>
<li>如果为前驱节点的<code>waitStatus</code>值为 <code>Node.CANCELLED</code> (ws &gt; 0), 则跳过那些节点, 重新寻找正常等待中的前驱节点，然后排在它后面，返回false</li>
<li>其他情况, 将前驱节点的状态改为 <code>Node.SIGNAL</code>, 返回false</li>
</ul>
<p>注意了，这个函数只有在当前节点的前驱节点的waitStatus状态本身就是SIGNAL的时候才会返回true, 其他时候都会返回false, 我们再回到这个方法的调用处：</p>
<div class="widget-codetool" style="display:none;">
        <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark far fa-copy rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();
            if (p == head &amp;&amp; tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return interrupted;
            }
            // 我们在这里！在这里！！在这里！！！
            // 我们在这里！在这里！！在这里！！！
            // 我们在这里！在这里！！在这里！！！
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}" title="" data-original-title="复制"></button>
        </div>
        </div><pre class="java hljs"><code class="java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-keyword">int</span> arg)</span> </span>{
    <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">for</span> (;;) {
            <span class="hljs-keyword">final</span> Node p = node.predecessor();
            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) {
                setHead(node);
                p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span>
                failed = <span class="hljs-keyword">false</span>;
                <span class="hljs-keyword">return</span> interrupted;
            }
            <span class="hljs-comment">// 我们在这里！在这里！！在这里！！！</span>
            <span class="hljs-comment">// 我们在这里！在这里！！在这里！！！</span>
            <span class="hljs-comment">// 我们在这里！在这里！！在这里！！！</span>
            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())
                interrupted = <span class="hljs-keyword">true</span>;
        }
    } <span class="hljs-keyword">finally</span> {
        <span class="hljs-keyword">if</span> (failed)
            cancelAcquire(node);
    }
}</code></pre>
<p>可以看出，当shouldParkAfterFailedAcquire返回false后，会继续回到循环中再次尝试获取锁——这是因为此时我们的前驱节点可能已经变了（搞不好前驱节点就变成head节点了呢）。</p>
<p>当shouldParkAfterFailedAcquire返回true，即当前节点的前驱节点的waitStatus状态已经设为SIGNAL后，我们就可以安心的将当前线程挂起了，此时我们将调用parkAndCheckInterrupt：</p>
<h3 id="item-5-12">parkAndCheckInterrupt</h3>
<p>到这个函数已经是最后一步了, 就是将线程挂起, 等待被唤醒</p>
<div class="widget-codetool" style="display:none;">
        <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark far fa-copy rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="private final boolean parkAndCheckInterrupt() {
    LockSupport.park(this); // 线程被挂起，停在这里不再往下执行了
    return Thread.interrupted();
}" title="" data-original-title="复制"></button>
        </div>
        </div><pre class="java hljs"><code class="java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">parkAndCheckInterrupt</span><span class="hljs-params">()</span> </span>{
    LockSupport.park(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// 线程被挂起，停在这里不再往下执行了</span>
    <span class="hljs-keyword">return</span> Thread.interrupted();
}</code></pre>
<p>注意！<code>LockSupport.park(this)</code>执行完成后线程就被挂起了，除非其他线程<code>unpark</code>了当前线程，或者当前线程被中断了，否则代码是不会再往下执行的，后面的<code>Thread.interrupted()</code>也不会被执行，那后面这个<code>Thread.interrupted()</code>是干什么用的呢？ 我们下一篇再讲。</p>
<h2 id="item-6">总结</h2>
<ol>
<li>AQS中用state属性表示锁，如果能成功将state属性通过CAS操作从0设置成1即获取了锁</li>
<li>获取了锁的线程才能将exclusiveOwnerThread设置成自己</li>
<li>addWaiter负责将当前等待锁的线程包装成Node,并成功地添加到队列的末尾，这一点是由它调用的enq方法保证的，enq方法同时还负责在队列为空时初始化队列。</li>
<li>acquireQueued方法用于在Node成功入队后，继续尝试获取锁（取决于Node的前驱节点是不是head），或者将线程挂起</li>
<li>shouldParkAfterFailedAcquire方法用于保证当前线程的前驱节点的waitStatus属性值为SIGNAL,从而保证了自己挂起后，前驱节点会负责在合适的时候唤醒自己。</li>
<li>parkAndCheckInterrupt方法用于挂起当前线程，并检查中断状态。</li>
<li>如果最终成功获取了锁，线程会从lock()方法返回，继续往下执行；否则，线程会阻塞等待。</li>
</ol>
<p>(完)</p>
<p>下一篇: <a href="https://segmentfault.com/a/1190000015752512">逐行分析AQS源码(2)——独占锁的释放</a></p>
<p>查看更多系列文章：<a href="https://segmentfault.com/a/1190000016058789">系列文章目录</a></p>
</article><div class="d-sm-flex d-none flex-wrap align-items-center"><div class="m-n1"><a href="https://segmentfault.com/t/java" class="m-1 badge-tag">java</a><a href="https://segmentfault.com/t/java%E5%B9%B6%E5%8F%91" class="m-1 badge-tag">java并发</a></div></div><div class="my-4"><div id="OA_holder_3" class="ad-container" style="display:block"><div class="d-none d-lg-flex justify-content-center">
<script async="" src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/f(6).txt"></script>
<!-- 中部横幅广告位 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-6330872677300335" data-ad-slot="5598290435" data-adsbygoogle-status="done"><ins id="aswift_0_expand" style="display:inline-table;border:none;height:90px;margin:0;padding:0;position:relative;visibility:visible;width:728px;background-color:transparent;" tabindex="0" title="Advertisement" aria-label="Advertisement"><ins id="aswift_0_anchor" style="display:block;border:none;height:90px;margin:0;padding:0;position:relative;visibility:visible;width:728px;background-color:transparent;"><iframe id="aswift_0" name="aswift_0" style="left:0;position:absolute;top:0;border:0;width:728px;height:90px;" sandbox="allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" width="728" height="90" frameborder="0" src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/ads.html" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" data-google-container-id="a!1" data-google-query-id="CKXdhM7o_e4CFUhqlgodK3QEPQ" data-load-complete="true"></iframe></ins></ins></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script><div id="beacon_4c70a62865" style="position: absolute; left: 0px; top: 0px; visibility: hidden;"><img src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/lg(3).php" width="0" height="0" alt="" style="width: 0px; height: 0px;"></div></div>
</div></div><div class="text-secondary font-size-14 mt-3 mb-5 d-flex justify-content-between row"><div class="col"><span>阅读 <!-- -->10.2k</span><span class="split-dot"></span><time datetime="2018-07-23T13:57:53.000Z" itemprop="datePublished">更新于 <!-- -->2018-09-18</time></div><div class="operation col-6 text-right col-xs-3 col"><div></div></div></div><div class="functional-area-bottom text-center"><div role="group" class="btn-group like-group align-items-center btn-group"><button type="button" class="btn mr-2 rounded btn btn-outline-primary"><i class="far fa-thumbs-up"></i><span class="ml-1">赞</span><span class="mainLikeNum ml-1">48</span></button><button type="button" class="btn mr-2 rounded btn btn-outline-secondary"><i class="far fa-bookmark"></i><span class="ml-1">收藏</span><span class="ml-1">19</span></button><div class="bottom-share-wrap dropdown"><a href="https://segmentfault.com/a/1190000015739343#" class="nav-tab-item  btn d-flex justify-content-center align-items-center dropdown-toggle" aria-label="分享"><button type="button" class="btn rounded btn btn-outline-secondary"><i class="far fa-share-alt"></i><span class="ml-1">分享</span></button></a></div></div></div><canvas hidden="" class="qrcode"></canvas><div class="font-size-14 text-secondary text-center mt-3 mb-5"><span>本作品系原创，</span><a target="_blank" rel="noreferrer" class="text-secondary" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">采用《署名-非商业性使用-禁止演绎 4.0 国际》许可协议</a></div><hr class="mb-0"><div class="d-flex flex-sm-row align-items-center pt-4 row"><div class="d-flex align-items-center flex-grow-1 author-left col-sm-9 col-12"><img class="mr-3 rounded" width="64" src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/3833030929-5ffd15fc110ab" aria-hidden="true"><div class="w-100"><a href="https://segmentfault.com/blog/chiucheng" class="text-body"><h5 class="mb-0">Keep Coding</h5></a><div class="text-truncate text-secondary mt-2">记录与分享</div></div></div><div class="author-right flex-shrink-0 col-sm-3 col-12 text-sm-right text-left mt-sm-0 mt-3" id="followUser"><button type="button" class="btn btn-primary">关注专栏</button></div></div></div></div><div class="d-block d-xl-none mt-sm-4"><div class="mb-4 border-0 card"><div class="card-body"><div class="d-flex align-items-center mb-3"><picture class="rounded-circle mr-3"><img src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/3179314346-5f61e47221e07" alt="avatar" width="64" height="64" class="rounded-circle"></picture><div><h5 class="mb-0"><a href="https://segmentfault.com/u/chiucheng" class="text-body">ChiuCheng</a></h5></div></div><div class="text-secondary text-truncate-2 userExcerpt mb-3"><p>Talk is cheap, show me the code！</p></div><div class="d-flex align-items-center mb-3"><div class="mr-4"><strong>885</strong><span class="text-secondary"> 声望</span></div><div><strong>170</strong><span class="text-secondary"> 粉丝</span></div></div><button type="button" class="btn btn-primary btn-block">关注作者</button></div></div></div><div id="comment-area"><div class="d-flex justify-content-between mb-2 px-4 px-md-0"><div id="comment-total" class="h5 mb-0">25<!-- --> 条评论</div><div><a href="https://segmentfault.com/a/1190000015739343#" class="sort text-dark">得票</a><span class="split-dot text-secondary"></span><a href="https://segmentfault.com/a/1190000015739343#" class="sort text-secondary">时间</a></div></div><div class="comment-wrap border-0  card"><div class="card-body"><div class="mb-4 media"><img src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/3179314346-5f61e47221e07" class="rounded-circle mr-3" width="38" aria-hidden="true"><div class="media-body"><div class="form-group"><textarea rows="1" placeholder="撰写评论 …" aria-label="评论" class="comment-text form-control" style="overflow: hidden; overflow-wrap: break-word; resize: none; height: 38px;" data-tribute="true"></textarea><div class="invalid-feedback"></div></div><div class="d-flex justify-content-end align-items-center"><a href="https://segmentfault.com/a/1190000015739343#" class="mr-3" aria-label="提示"><i class="far fa-info-circle text-secondary"></i></a><button disabled="" type="button" class="float-right btn btn-primary">提交评论</button></div></div></div><div class="comment-body-wrap false"><div class="mb-r d-flex align-items-start mb-4 media"><img class="d-block rounded-circle mr-3" width="38" height="38" src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/3179314346-5f61e47221e07" alt=""><div class="w-0  media-body"><div class="commentUnit "><div class="mb-1"><a class="d-uname" href="https://segmentfault.com/u/zuko" rel="noreferrer" target="_blank"><strong>zuko</strong></a>：<div class="parsedText fmt"><p>看其它文章的时候，总是搞不懂为什么是从尾结点向前遍历，看你讲的尾分叉恍然大悟！！！</p></div></div><div class="handle-bar font-size-14 d-flex justify-content-between"><div><a class="text-secondary" href="https://segmentfault.com/a/1190000015739343#"><span class="mainLike-comment "><i class="fa-w-16 far fa-thumbs-up" style="width: 1em;"></i></span><span class="mainLike-commentNum ml-1">1</span></a><span class="split-dot"></span><a class="text-secondary btn-comment" href="https://segmentfault.com/a/1190000015739343#">回复</a><span class="split-dot"></span><span class="text-secondary">2019-07-12</span></div><div class="control-area d-none"></div></div></div><div class="replies hidden"><div class="bg-light border-0 mt-2 card"><div class="p-3 card-body"><div class="reply-list list-group"></div></div></div></div></div></div><div class="mb-r d-flex align-items-start mb-4 media"><img class="d-block rounded-circle mr-3" width="38" height="38" src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/3287537642-58cba8b5a27a0_big64" alt=""><div class="w-0  media-body"><div class="commentUnit "><div class="mb-1"><a class="d-uname" href="https://segmentfault.com/u/beanlam" rel="noreferrer" target="_blank"><strong>beanlam</strong></a>：<div class="parsedText fmt"><p>看过这么多分析AQS的文章，你的文章写得是最好的</p></div></div><div class="handle-bar font-size-14 d-flex justify-content-between"><div><a class="text-secondary" href="https://segmentfault.com/a/1190000015739343#"><span class="mainLike-comment "><i class="fa-w-16 far fa-thumbs-up" style="width: 1em;"></i></span></a><span class="split-dot"></span><a class="text-secondary btn-comment" href="https://segmentfault.com/a/1190000015739343#">回复</a><span class="split-dot"></span><span class="text-secondary">2018-10-26</span></div><div class="control-area d-none"></div></div></div><div class="replies "><div class="bg-light border-0 mt-2 card"><div class="p-3 card-body"><div class="reply-list list-group"><div class="p-0 border-0 commentUnit false   list-group-item"><div class="font-size-14 mb-1"><a class="d-uname" href="https://segmentfault.com/u/chiucheng" target="_blank" rel="noreferrer"><strong>ChiuCheng</strong><span class="text-secondary">（作者）</span></a>：<div class="parsedText fmt"><p>谢谢！</p></div></div><div class="handle-bar font-size-14 d-flex justify-content-between"><div><a class="text-secondary" href="https://segmentfault.com/a/1190000015739343#"><span class="mainLike-comment "><i class="fa-w-16 far fa-thumbs-up" style="width: 1em;"></i></span></a><span class="split-dot"></span><a class="text-secondary btn-reply" href="https://segmentfault.com/a/1190000015739343#">回复</a><span class="split-dot"></span><span class="text-secondary">2018-10-29</span></div><div class="comment-control-area d-none"></div></div></div></div></div></div></div></div></div><div class="mb-r d-flex align-items-start mb-4 media"><img class="d-block rounded-circle mr-3" width="38" height="38" src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/3179314346-5f61e47221e07" alt=""><div class="w-0  media-body"><div class="commentUnit "><div class="mb-1"><a class="d-uname" href="https://segmentfault.com/u/dannashen" rel="noreferrer" target="_blank"><strong>DannaShen</strong></a>：<div class="parsedText fmt"><p>这篇文章写的太好了，佩服！</p></div></div><div class="handle-bar font-size-14 d-flex justify-content-between"><div><a class="text-secondary" href="https://segmentfault.com/a/1190000015739343#"><span class="mainLike-comment "><i class="fa-w-16 far fa-thumbs-up" style="width: 1em;"></i></span></a><span class="split-dot"></span><a class="text-secondary btn-comment" href="https://segmentfault.com/a/1190000015739343#">回复</a><span class="split-dot"></span><span class="text-secondary">2019-03-20</span></div><div class="control-area d-none"></div></div></div><div class="replies hidden"><div class="bg-light border-0 mt-2 card"><div class="p-3 card-body"><div class="reply-list list-group"></div></div></div></div></div></div><div class="mb-r d-flex align-items-start mb-4 media"><img class="d-block rounded-circle mr-3" width="38" height="38" src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/3179314346-5f61e47221e07" alt=""><div class="w-0  media-body"><div class="commentUnit "><div class="mb-1"><a class="d-uname" href="https://segmentfault.com/u/dannashen" rel="noreferrer" target="_blank"><strong>DannaShen</strong></a>：<div class="parsedText fmt"><p>你对技术的理解很透很清晰，看了好几天AQS，总感觉不够，看到你写的，实在太赞了！</p></div></div><div class="handle-bar font-size-14 d-flex justify-content-between"><div><a class="text-secondary" href="https://segmentfault.com/a/1190000015739343#"><span class="mainLike-comment "><i class="fa-w-16 far fa-thumbs-up" style="width: 1em;"></i></span></a><span class="split-dot"></span><a class="text-secondary btn-comment" href="https://segmentfault.com/a/1190000015739343#">回复</a><span class="split-dot"></span><span class="text-secondary">2019-03-20</span></div><div class="control-area d-none"></div></div></div><div class="replies hidden"><div class="bg-light border-0 mt-2 card"><div class="p-3 card-body"><div class="reply-list list-group"></div></div></div></div></div></div><div class="mb-r d-flex align-items-start mb-4 media"><img class="d-block rounded-circle mr-3" width="38" height="38" src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/3179314346-5f61e47221e07" alt=""><div class="w-0  media-body"><div class="commentUnit "><div class="mb-1"><a class="d-uname" href="https://segmentfault.com/u/vistar" rel="noreferrer" target="_blank"><strong>Vistar</strong></a>：<div class="parsedText fmt"><p>楼主还是本科生吗？真厉害！</p></div></div><div class="handle-bar font-size-14 d-flex justify-content-between"><div><a class="text-secondary" href="https://segmentfault.com/a/1190000015739343#"><span class="mainLike-comment "><i class="fa-w-16 far fa-thumbs-up" style="width: 1em;"></i></span></a><span class="split-dot"></span><a class="text-secondary btn-comment" href="https://segmentfault.com/a/1190000015739343#">回复</a><span class="split-dot"></span><span class="text-secondary">2019-06-19</span></div><div class="control-area d-none"></div></div></div><div class="replies hidden"><div class="bg-light border-0 mt-2 card"><div class="p-3 card-body"><div class="reply-list list-group"></div></div></div></div></div></div><div class="mb-r d-flex align-items-start mb-4 media"><img class="d-block rounded-circle mr-3" width="38" height="38" src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/3179314346-5f61e47221e07" alt=""><div class="w-0  media-body"><div class="commentUnit "><div class="mb-1"><a class="d-uname" href="https://segmentfault.com/u/shiying_5acc551fb166a" rel="noreferrer" target="_blank"><strong>石英</strong></a>：<div class="parsedText fmt"><p>作者的思路很清晰，文笔很不错，写这个帖子花费了不少精力吧</p></div></div><div class="handle-bar font-size-14 d-flex justify-content-between"><div><a class="text-secondary" href="https://segmentfault.com/a/1190000015739343#"><span class="mainLike-comment "><i class="fa-w-16 far fa-thumbs-up" style="width: 1em;"></i></span></a><span class="split-dot"></span><a class="text-secondary btn-comment" href="https://segmentfault.com/a/1190000015739343#">回复</a><span class="split-dot"></span><span class="text-secondary">2019-06-23</span></div><div class="control-area d-none"></div></div></div><div class="replies hidden"><div class="bg-light border-0 mt-2 card"><div class="p-3 card-body"><div class="reply-list list-group"></div></div></div></div></div></div><div class="mb-r d-flex align-items-start mb-4 media"><img class="d-block rounded-circle mr-3" width="38" height="38" src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/3179314346-5f61e47221e07" alt=""><div class="w-0  media-body"><div class="commentUnit "><div class="mb-1"><a class="d-uname" href="https://segmentfault.com/u/kaerweinuo_5d26dccde22de" rel="noreferrer" target="_blank"><strong>卡尔维诺</strong></a>：<div class="parsedText fmt"><p>这也太棒了吧!!思路清晰,深刻的理解才能写出深刻的文章!!</p></div></div><div class="handle-bar font-size-14 d-flex justify-content-between"><div><a class="text-secondary" href="https://segmentfault.com/a/1190000015739343#"><span class="mainLike-comment "><i class="fa-w-16 far fa-thumbs-up" style="width: 1em;"></i></span></a><span class="split-dot"></span><a class="text-secondary btn-comment" href="https://segmentfault.com/a/1190000015739343#">回复</a><span class="split-dot"></span><span class="text-secondary">2019-07-11</span></div><div class="control-area d-none"></div></div></div><div class="replies hidden"><div class="bg-light border-0 mt-2 card"><div class="p-3 card-body"><div class="reply-list list-group"></div></div></div></div></div></div><div class="mb-r d-flex align-items-start mb-4 media"><img class="d-block rounded-circle mr-3" width="38" height="38" src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/3179314346-5f61e47221e07" alt=""><div class="w-0  media-body"><div class="commentUnit "><div class="mb-1"><a class="d-uname" href="https://segmentfault.com/u/_5d5521d9232f6" rel="noreferrer" target="_blank"><strong>喵喵</strong></a>：<div class="parsedText fmt">
<p>感谢楼主这么好的文章。不过我有一点疑问：<br>private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {</p>
<pre><code>int ws = pred.waitStatus; // 获得前驱节点的ws
if (ws == Node.SIGNAL)
    // 前驱节点的状态已经是SIGNAL了，说明闹钟已经设了，可以直接睡了
    return true;
if (ws &gt; 0) {
    // 当前节点的 ws &gt; 0, 则为 Node.CANCELLED 说明前驱节点已经取消了等待锁(由于超时或者中断等原因)
    // 既然前驱节点不等了, 那就继续往前找, 直到找到一个还在等待锁的节点
    // 然后我们跨过这些不等待锁的节点, 直接排在等待锁的节点的后面 (是不是很开心!!!)
    do {
        node.prev = pred = pred.prev;
    } while (pred.waitStatus &gt; 0);
    pred.next = node;
} else {
    // 前驱节点的状态既不是SIGNAL，也不是CANCELLED
    // 用CAS设置前驱节点的ws为 Node.SIGNAL，给自己定一个闹钟
    compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
}
return false;</code></pre>
<p>}<br>其中的：</p>
<pre><code> do {
        node.prev = pred = pred.prev;
    } while (pred.waitStatus &gt; 0);
    pred.next = node;
</code></pre>
<p>您的解释也非常的清楚，这一操作使得当前线程节点跨过那些不再等待锁的线程节点，但是这个操作是在改变排队的队列呀，为什么都不使用同步操作呢？这样能保证线程安全吗？希望您百忙之中能帮忙解答我的困惑，谢谢！</p>
</div></div><div class="handle-bar font-size-14 d-flex justify-content-between"><div><a class="text-secondary" href="https://segmentfault.com/a/1190000015739343#"><span class="mainLike-comment "><i class="fa-w-16 far fa-thumbs-up" style="width: 1em;"></i></span></a><span class="split-dot"></span><a class="text-secondary btn-comment" href="https://segmentfault.com/a/1190000015739343#">回复</a><span class="split-dot"></span><span class="text-secondary">2019-08-15</span></div><div class="control-area d-none"></div></div></div><div class="replies "><div class="bg-light border-0 mt-2 card"><div class="p-3 card-body"><div class="reply-list list-group"><div class="p-0 border-0 commentUnit mb-3   list-group-item"><div class="font-size-14 mb-1"><a class="d-uname" href="https://segmentfault.com/u/yuzhibowukong" target="_blank" rel="noreferrer"><strong>宇智波悟空</strong></a>：<div class="parsedText fmt"><p>这处无法确实无法串行执行，但可以保证保证队列前后关系不变。而AQS中只要前后顺序不改变就不会改变唤醒逻辑。但这只是我的个人看法，仅供参考</p></div></div><div class="handle-bar font-size-14 d-flex justify-content-between"><div><a class="text-secondary" href="https://segmentfault.com/a/1190000015739343#"><span class="mainLike-comment "><i class="fa-w-16 far fa-thumbs-up" style="width: 1em;"></i></span></a><span class="split-dot"></span><a class="text-secondary btn-reply" href="https://segmentfault.com/a/1190000015739343#">回复</a><span class="split-dot"></span><span class="text-secondary">2019-08-19</span></div><div class="comment-control-area d-none"></div></div></div><div class="p-0 border-0 commentUnit mb-3   list-group-item"><div class="font-size-14 mb-1"><a class="d-uname" href="https://segmentfault.com/u/youngkangrui" target="_blank" rel="noreferrer"><strong>youngkangrui</strong></a>：<div class="parsedText fmt"><p>假设a节点入队，往前找的途中，b节点入队，也往前找，b线程不会和a线程有竞争关系，因为a此时waitstatus为0，b最多是往前排到a的后面</p></div></div><div class="handle-bar font-size-14 d-flex justify-content-between"><div><a class="text-secondary" href="https://segmentfault.com/a/1190000015739343#"><span class="mainLike-comment "><i class="fa-w-16 far fa-thumbs-up" style="width: 1em;"></i></span></a><span class="split-dot"></span><a class="text-secondary btn-reply" href="https://segmentfault.com/a/1190000015739343#">回复</a><span class="split-dot"></span><span class="text-secondary">2019-11-16</span></div><div class="comment-control-area d-none"></div></div></div><div class="p-0 border-0 commentUnit false   list-group-item"><div class="font-size-14 mb-1"><a class="d-uname" href="https://segmentfault.com/u/suiyueshentou_5e6628b4ef19a" target="_blank" rel="noreferrer"><strong>岁月神偷</strong></a>：<div class="parsedText fmt"><p>我觉得需要通过acquireQueued总体来分析，进入shouldParkAfterFailedAcquire方法的线程如果在判断waitStatus并进入方法执行体的准备执行的那一刻或者执行成功后waitStatus状态被改变（为什么在排队中waitStatus状态会被设置为CANCELLED呢，那肯定是有对其操作的地方），那么他的三种情况的执行体都应该加上原子操作，只有第三种加上了原子操作，就不讨论了。<br>针对你所指的问题，他的功能在于排在等锁的节点后(这里采用的是公平锁，所以一定会有一个等待时间最长的线程，所以需要排在他后面，反之非公平锁不遵循此规则)，无论排序中waitStatus状态是否被修改(被修改的情况有两类，即正常或非正常)，那么内部排序出现未达到理想状态(在车站排队的时候也会有人进进出出)，但是他最终都会被返回，要么被挂起（即使被唤醒还是要去循环体抢锁）；要么继续执行死循环循环体，尝试抢锁（抢锁是原子操作）或者再次进去到shouldParkAfterFailedAcquire直到达到目的为止。在实际开发中大量的线程自旋会占用CPU资源，所以所以需要规定一定时间的自旋时间，当超过这个时间，则线程自动进入阻塞态。<br>以上是我个人见解，如有其他思路，欢迎讨论。</p></div></div><div class="handle-bar font-size-14 d-flex justify-content-between"><div><a class="text-secondary" href="https://segmentfault.com/a/1190000015739343#"><span class="mainLike-comment "><i class="fa-w-16 far fa-thumbs-up" style="width: 1em;"></i></span></a><span class="split-dot"></span><a class="text-secondary btn-reply" href="https://segmentfault.com/a/1190000015739343#">回复</a><span class="split-dot"></span><span class="text-secondary">2020-03-10</span></div><div class="comment-control-area d-none"></div></div></div></div><div class="font-size-14 d-flex mt-3 loader d-none"><a class="text-secondary next-page-btn" href="https://segmentfault.com/a/1190000015739343#">共 4 条回复</a></div></div></div></div></div></div><div class="mb-r d-flex align-items-start mb-4 media"><img class="d-block rounded-circle mr-3" width="38" height="38" src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/3179314346-5f61e47221e07" alt=""><div class="w-0  media-body"><div class="commentUnit "><div class="mb-1"><a class="d-uname" href="https://segmentfault.com/u/lengshanren" rel="noreferrer" target="_blank"><strong>楞伽山人</strong></a>：<div class="parsedText fmt"><p>compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br>楼主 这一段是为啥要使用cas？</p></div></div><div class="handle-bar font-size-14 d-flex justify-content-between"><div><a class="text-secondary" href="https://segmentfault.com/a/1190000015739343#"><span class="mainLike-comment "><i class="fa-w-16 far fa-thumbs-up" style="width: 1em;"></i></span></a><span class="split-dot"></span><a class="text-secondary btn-comment" href="https://segmentfault.com/a/1190000015739343#">回复</a><span class="split-dot"></span><span class="text-secondary">2019-09-12</span></div><div class="control-area d-none"></div></div></div><div class="replies "><div class="bg-light border-0 mt-2 card"><div class="p-3 card-body"><div class="reply-list list-group"><div class="p-0 border-0 commentUnit false   list-group-item"><div class="font-size-14 mb-1"><a class="d-uname" href="https://segmentfault.com/u/youngkangrui" target="_blank" rel="noreferrer"><strong>youngkangrui</strong></a>：<div class="parsedText fmt"><p>因为这个时候pred前驱节点有可能已经变成cancel</p></div></div><div class="handle-bar font-size-14 d-flex justify-content-between"><div><a class="text-secondary" href="https://segmentfault.com/a/1190000015739343#"><span class="mainLike-comment "><i class="fa-w-16 far fa-thumbs-up" style="width: 1em;"></i></span></a><span class="split-dot"></span><a class="text-secondary btn-reply" href="https://segmentfault.com/a/1190000015739343#">回复</a><span class="split-dot"></span><span class="text-secondary">2019-11-16</span></div><div class="comment-control-area d-none"></div></div></div></div></div></div></div></div></div><div class="mb-r d-flex align-items-start mb-4 media"><img class="d-block rounded-circle mr-3" width="38" height="38" src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/3179314346-5f61e47221e07" alt=""><div class="w-0  media-body"><div class="commentUnit "><div class="mb-1"><a class="d-uname" href="https://segmentfault.com/u/nevermore_5d961aecd3134" rel="noreferrer" target="_blank"><strong>Nevermore</strong></a>：<div class="parsedText fmt"><p>写的太好了！</p></div></div><div class="handle-bar font-size-14 d-flex justify-content-between"><div><a class="text-secondary" href="https://segmentfault.com/a/1190000015739343#"><span class="mainLike-comment "><i class="fa-w-16 far fa-thumbs-up" style="width: 1em;"></i></span></a><span class="split-dot"></span><a class="text-secondary btn-comment" href="https://segmentfault.com/a/1190000015739343#">回复</a><span class="split-dot"></span><span class="text-secondary">2019-10-04</span></div><div class="control-area d-none"></div></div></div><div class="replies hidden"><div class="bg-light border-0 mt-2 card"><div class="p-3 card-body"><div class="reply-list list-group"></div></div></div></div></div></div><div class="mb-r d-flex align-items-start mb-4 media"><img class="d-block rounded-circle mr-3" width="38" height="38" src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/3179314346-5f61e47221e07" alt=""><div class="w-0  media-body"><div class="commentUnit "><div class="mb-1"><a class="d-uname" href="https://segmentfault.com/u/xingxing_5a9cb5d849b98" rel="noreferrer" target="_blank"><strong>星星</strong></a>：<div class="parsedText fmt"><p>这个尾分叉的解释让我理解了为什么某些情况下需要判断节点值为null的情况，感谢，很好的文章！</p></div></div><div class="handle-bar font-size-14 d-flex justify-content-between"><div><a class="text-secondary" href="https://segmentfault.com/a/1190000015739343#"><span class="mainLike-comment "><i class="fa-w-16 far fa-thumbs-up" style="width: 1em;"></i></span></a><span class="split-dot"></span><a class="text-secondary btn-comment" href="https://segmentfault.com/a/1190000015739343#">回复</a><span class="split-dot"></span><span class="text-secondary">2019-11-02</span></div><div class="control-area d-none"></div></div></div><div class="replies hidden"><div class="bg-light border-0 mt-2 card"><div class="p-3 card-body"><div class="reply-list list-group"></div></div></div></div></div></div><div class="mb-r d-flex align-items-start mb-4 media"><img class="d-block rounded-circle mr-3" width="38" height="38" src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/3720241423-5e03548631e40_big64" alt=""><div class="w-0  media-body"><div class="commentUnit "><div class="mb-1"><a class="d-uname" href="https://segmentfault.com/u/senknight" rel="noreferrer" target="_blank"><strong>SenKnight</strong></a>：<div class="parsedText fmt"><p>楼主牛人，想知道你这图是用什么画的？</p></div></div><div class="handle-bar font-size-14 d-flex justify-content-between"><div><a class="text-secondary" href="https://segmentfault.com/a/1190000015739343#"><span class="mainLike-comment "><i class="fa-w-16 far fa-thumbs-up" style="width: 1em;"></i></span></a><span class="split-dot"></span><a class="text-secondary btn-comment" href="https://segmentfault.com/a/1190000015739343#">回复</a><span class="split-dot"></span><span class="text-secondary">2019-12-25</span></div><div class="control-area d-none"></div></div></div><div class="replies hidden"><div class="bg-light border-0 mt-2 card"><div class="p-3 card-body"><div class="reply-list list-group"></div></div></div></div></div></div><div class="mb-r d-flex align-items-start mb-4 media"><img class="d-block rounded-circle mr-3" width="38" height="38" src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/3179314346-5f61e47221e07" alt=""><div class="w-0  media-body"><div class="commentUnit "><div class="mb-1"><a class="d-uname" href="https://segmentfault.com/u/balahat" rel="noreferrer" target="_blank"><strong>娟儿</strong></a>：<div class="parsedText fmt"><p>非常感谢楼主的好文章</p></div></div><div class="handle-bar font-size-14 d-flex justify-content-between"><div><a class="text-secondary" href="https://segmentfault.com/a/1190000015739343#"><span class="mainLike-comment "><i class="fa-w-16 far fa-thumbs-up" style="width: 1em;"></i></span></a><span class="split-dot"></span><a class="text-secondary btn-comment" href="https://segmentfault.com/a/1190000015739343#">回复</a><span class="split-dot"></span><span class="text-secondary">2020-03-14</span></div><div class="control-area d-none"></div></div></div><div class="replies hidden"><div class="bg-light border-0 mt-2 card"><div class="p-3 card-body"><div class="reply-list list-group"></div></div></div></div></div></div><div class="mb-r d-flex align-items-start mb-4 media"><img class="d-block rounded-circle mr-3" width="38" height="38" src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/3179314346-5f61e47221e07" alt=""><div class="w-0  media-body"><div class="commentUnit "><div class="mb-1"><a class="d-uname" href="https://segmentfault.com/u/kaerweinuo_5d26dccde22de" rel="noreferrer" target="_blank"><strong>卡尔维诺</strong></a>：<div class="parsedText fmt"><p>爱你哦</p></div></div><div class="handle-bar font-size-14 d-flex justify-content-between"><div><a class="text-secondary" href="https://segmentfault.com/a/1190000015739343#"><span class="mainLike-comment "><i class="fa-w-16 far fa-thumbs-up" style="width: 1em;"></i></span></a><span class="split-dot"></span><a class="text-secondary btn-comment" href="https://segmentfault.com/a/1190000015739343#">回复</a><span class="split-dot"></span><span class="text-secondary">2020-04-20</span></div><div class="control-area d-none"></div></div></div><div class="replies hidden"><div class="bg-light border-0 mt-2 card"><div class="p-3 card-body"><div class="reply-list list-group"></div></div></div></div></div></div><div class="mb-r d-flex align-items-start false media"><img class="d-block rounded-circle mr-3" width="38" height="38" src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/3179314346-5f61e47221e07" alt=""><div class="w-0  media-body"><div class="commentUnit "><div class="mb-1"><a class="d-uname" href="https://segmentfault.com/u/yangshangxu" rel="noreferrer" target="_blank"><strong>杨尚旭</strong></a>：<div class="parsedText fmt"><p>你的思路真的清晰,666!</p></div></div><div class="handle-bar font-size-14 d-flex justify-content-between"><div><a class="text-secondary" href="https://segmentfault.com/a/1190000015739343#"><span class="mainLike-comment "><i class="fa-w-16 far fa-thumbs-up" style="width: 1em;"></i></span></a><span class="split-dot"></span><a class="text-secondary btn-comment" href="https://segmentfault.com/a/1190000015739343#">回复</a><span class="split-dot"></span><span class="text-secondary">2020-04-25</span></div><div class="control-area d-none"></div></div></div><div class="replies hidden"><div class="bg-light border-0 mt-2 card"><div class="p-3 card-body"><div class="reply-list list-group"></div></div></div></div></div></div></div><div class="d-flex justify-content-center mt-4 mb-1"><ul class="mb-0 pagination pagination-sm"><li class="page-item"><a class="page-link" role="button" href="https://segmentfault.com/a/1190000015739343#">上一页</a></li><li class="page-item"><a class="page-link" role="button" href="https://segmentfault.com/a/1190000015739343#">1</a></li><li class="page-item"><a class="page-link" role="button" href="https://segmentfault.com/a/1190000015739343#">2</a></li><li class="page-item"><a class="page-link" role="button" href="https://segmentfault.com/a/1190000015739343#">下一页</a></li></ul></div></div></div></div><div class="recommend-list-wrap mt-4 list-group"><h5 class="h5 mb-2 px-4 px-md-0" style="font-weight: 600;">推荐阅读</h5><div class="card border-0"><div class="list-group list-group-flush"><a class="list-group-item list-group-item-action py-3" href="https://segmentfault.com/a/1190000017115722?utm_source=sf-related" target="_blank"><h5 class="h5 mb-2 text-break" style="color: rgb(33, 37, 41);">墙裂推荐：搜云库技术团队，面试必备的技术干货</h5><p class="mb-2 text-truncate text-secondary">今天整理了一下近大半年以来的一些文章，和我的预期一样，很多文章我都忘记自己曾经写过了，这个记录的过程让我也有了新的理解。希望大家，收藏，点赞，加转发。</p><p class="d-flex align-items-center font-size-14 mb-0"><span class="text-primary">搜云库技术团队</span><span class="split-dot"></span><span>阅读 10.2k</span><span class="split-dot"></span><span>64 赞</span></p></a><a class="list-group-item list-group-item-action py-3" href="https://segmentfault.com/a/1190000008471362?utm_source=sf-related" target="_blank"><h5 class="h5 mb-2 text-break" style="color: rgb(33, 37, 41);">浅谈Java并发编程系列（九）—— AQS结构及原理分析</h5><p class="mb-2 text-truncate text-secondary">AQS，即AbstractQueuedSynchronizer, 队列同步器，它是Java并发用来构建锁和其他同步组件的基础框架。来看下同步组件对AQS的使用：</p><p class="d-flex align-items-center font-size-14 mb-0"><span class="text-primary">codershamo</span><span class="split-dot"></span><span>阅读 19.4k</span><span class="split-dot"></span><span>22 赞</span></p></a><a class="list-group-item list-group-item-action py-3" href="https://segmentfault.com/a/1190000016344364?utm_source=sf-related" target="_blank"><h5 class="h5 mb-2 text-break" style="color: rgb(33, 37, 41);">Java并发编程：AbstractQueuedSynchronizer的内部结构</h5><p class="mb-2 text-truncate text-secondary">虽然已经有很多前辈已经分析过AbstractQueuedSynchronizer（简称AQS，也叫队列同步器）类，但是感觉那些点始终是别人的，看一遍甚至几遍终不会印象深刻。所以还是记录下来印象更深刻，还能和大家一起探讨（这就是...</p><p class="d-flex align-items-center font-size-14 mb-0"><span class="text-primary">bali</span><span class="split-dot"></span><span>阅读 574</span><span class="split-dot"></span><span>14 赞</span></p></a><a class="list-group-item list-group-item-action py-3" href="https://segmentfault.com/a/1190000022322202?utm_source=sf-related" target="_blank"><h5 class="h5 mb-2 text-break" style="color: rgb(33, 37, 41);">java与cas、aqs</h5><p class="mb-2 text-truncate text-secondary">其实这行代码可以拆成两部分：1.首先是=右面的运算部分，我们得出了一个值。2.第二步我们把这个值赋给了index，但这两部并不是一个原子操作，其它线程是可以插到这两步中间执行的，所以当我们赋值时这个index可能...</p><p class="d-flex align-items-center font-size-14 mb-0"><span class="text-primary">搬砖的张飞</span><span class="split-dot"></span><span>阅读 332</span><span class="split-dot"></span><span>4 赞</span></p></a><a class="list-group-item list-group-item-action py-3" href="https://segmentfault.com/a/1190000022493996?utm_source=sf-related" target="_blank"><h5 class="h5 mb-2 text-break" style="color: rgb(33, 37, 41);">Java多线程基础与并发编程学习笔记目录</h5><p class="mb-2 text-truncate text-secondary">最近在学习两个并发教程, 过完第一遍, 感触颇多.最大的感触就是: 学习还是要系统, 针对性地练, 才好掌握.这里列个目录, 后续陆续记录每个知识点, 包括理论依据和代码案例, 以加深和巩固记忆. 所学课程链接: https...</p><p class="d-flex align-items-center font-size-14 mb-0"><span class="text-primary">niewj</span><span class="split-dot"></span><span>阅读 424</span><span class="split-dot"></span><span>1 赞</span></p></a><a class="list-group-item list-group-item-action py-3" href="https://segmentfault.com/a/1190000038679481?utm_source=sf-related" target="_blank"><h5 class="h5 mb-2 text-break" style="color: rgb(33, 37, 41);">Java 并发底层知识，锁获取超时机制知多少？</h5><p class="mb-2 text-truncate text-secondary">当我们在使用Java进行网络编程时经常会遇到很多超时的概念，比如一个浏览器请求过程就可能会产生很多超时的地方，当我们在浏览器发起一个请求后，网络socket读写可能会超时，web服务器响应可能会超时，数据库查询...</p><p class="d-flex align-items-center font-size-14 mb-0"><span class="text-primary">码农架构</span><span class="split-dot"></span><span>阅读 112</span></p></a><a class="list-group-item list-group-item-action py-3" href="https://segmentfault.com/a/1190000038558825?utm_source=sf-related" target="_blank"><h5 class="h5 mb-2 text-break" style="color: rgb(33, 37, 41);">Java 并发编程：AQS 的原子性如何保证</h5><p class="mb-2 text-truncate text-secondary">当我们研究AQS框架时(对于AQS不太熟知可以先阅读《什么是JDK内置并发框架AQS》，会发现AbstractQueuedSynchronizer这个类很多地方都使用了CAS操作。在并发实现中CAS操作必须具备原子性，而且是硬件级别的原子性。...</p><p class="d-flex align-items-center font-size-14 mb-0"><span class="text-primary">码农架构</span><span class="split-dot"></span><span>阅读 138</span></p></a><a class="list-group-item list-group-item-action py-3" href="https://segmentfault.com/a/1190000020035632?utm_source=sf-related" target="_blank"><h5 class="h5 mb-2 text-break" style="color: rgb(33, 37, 41);">Java并发指南7：JUC的核心类AQS详解</h5><p class="mb-2 text-truncate text-secondary">在分析 Java 并发包 java.util.concurrent 源码的时候，少不了需要了解 AbstractQueuedSynchronizer（以下简写AQS）这个抽象类，因为它是 Java 并发包的基础工具类，是实现 ReentrantLock、CountDownLatch、Semap...</p><p class="d-flex align-items-center font-size-14 mb-0"><span class="text-primary">黄小斜</span><span class="split-dot"></span><span>阅读 292</span></p></a></div></div></div></div><div class="col-12 col-xl-auto col"><div class="w-xl-300"><div class="w-xl-300 d-none d-xl-block" id="author" style="top: 81.2px;"><div class="mb-4 border-0 card"><div class="card-body"><div class="d-flex align-items-center mb-3"><picture class="rounded-circle mr-3"><img src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/3179314346-5f61e47221e07" alt="avatar" width="64" height="64" class="rounded-circle"></picture><div><h5 class="mb-0"><a href="https://segmentfault.com/u/chiucheng" class="text-body">ChiuCheng</a></h5></div></div><div class="text-secondary text-truncate-2 userExcerpt mb-3"><p>Talk is cheap, show me the code！</p></div><div class="d-flex align-items-center mb-3"><div class="mr-4"><strong>885</strong><span class="text-secondary"> 声望</span></div><div><strong>170</strong><span class="text-secondary"> 粉丝</span></div></div><button type="button" class="btn btn-primary btn-block">关注作者</button></div></div></div><div class="w-xl-300 mb-4" id="first-ad" style="top: 343.2px;"><div class="card border-0 overflow-hidden d-none d-xl-flex justify-content-center align-items-center float-ads"><div id="OA_holder_1" class="ad-container" style="display:block"><div style="line-height: 0"><div class="ad-close" style="position: relative;"><a href="https://sponsor.segmentfault.com/ck.php?oaparams=2__bannerid=457__zoneid=1__cb=8098388cc5__oadest=https%3A%2F%2Fignitechina.microsoft.com%2Findex.html%3Fchannel_id%3D46%26channel_name%3Dchannel1%26tag_id%3D560fba931d9f7cd7" target="_blank"><img src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/6454888094bcb4d884acb7ba394f3b4e.jpeg" width="300" height="250" alt="" title="" border="0"></a><div id="beacon_8098388cc5" style="position: absolute; left: 0px; top: 0px; visibility: hidden;"><img src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/lg(4).php" width="0" height="0" alt="" style="width: 0px; height: 0px;"></div><div class="sflex-center ad-close-div" style="width: 16px; height: 16px; position: absolute; right: 8px; top: 8px; background-color: rgba(0, 0, 0, 0.75); cursor: pointer; pointer-events: none; border-radius: 50%;"><span class="ad-close-span" style="width: 8px; height: 8px; display: block; background-image: url(&quot;data:image/svg+xml,%3Csvg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;8&#39; height=&#39;8&#39;%3E%3Cpath fill=&#39;%23FFF&#39; fill-rule=&#39;evenodd&#39; d=&#39;M6.6667 0L8 1.3333 5.333 4 8 6.6667 6.6667 8 4 5.333 1.3333 8 0 6.6667 2.666 4 0 1.3333 1.3333 0 4 2.667 6.6667 0z&#39;/%3E%3C/svg%3E&quot;); background-repeat: no-repeat; background-position: center center; pointer-events: auto;"></span></div></div></div>
</div></div></div><div id="gridAd" class="d-none d-xl-block mb-4"><div class="border-0 card"><div class="bg-white border-0 card-header"><h5 class="mb-0">宣传栏</h5></div><div class="card-body"><div class="mb-3"><div id="OA_holder_7" class="ad-container" style="display:block"><a href="https://sponsor.segmentfault.com/ck.php?oaparams=2__bannerid=401__zoneid=7__cb=5a4a61778e__oadest=https%3A%2F%2Fke.sifou.com%2Fcourse%2F1650000037474720%3Futm_source%3Dsegmentfault%26utm_medium%3Dbanner_Tlink" target="_blank"><strong>专家带你构建一个高性能秒杀系统</strong><br>
<small style="color: #6c757d">大厂电商 Java 秒杀系统架构实战</small></a><div id="beacon_5a4a61778e" style="position: absolute; left: 0px; top: 0px; visibility: hidden;"><img src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/lg(5).php" width="0" height="0" alt="" style="width: 0px; height: 0px;"></div>
</div></div><div class="mb-3"><div id="OA_holder_9" class="ad-container" style="display:block"><a href="https://sponsor.segmentfault.com/ck.php?oaparams=2__bannerid=400__zoneid=9__cb=93308b3c95__oadest=https%3A%2F%2Fke.sifou.com%2Fcourse%2F1650000023864436%3Futm_source%3Dsegmentfault%26utm_medium%3Dbanner_Tlink" target="_blank"><strong>自顶向下学 React 源码</strong><br>
<small style="color: #6c757d">从理念到架构到实现到代码，透彻理解 </small></a><div id="beacon_93308b3c95" style="position: absolute; left: 0px; top: 0px; visibility: hidden;"><img src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/lg(6).php" width="0" height="0" alt="" style="width: 0px; height: 0px;"></div>
</div></div><div><div id="OA_holder_10" class="ad-container" style="display:block"><div id="beacon_f773d41449" style="position: absolute; left: 0px; top: 0px; visibility: hidden;"><img src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/lg(7).php" width="0" height="0" alt="" style="width: 0px; height: 0px;"></div>
</div></div></div></div></div><div id="second-ad" class="d-none d-xl-block" style="top: auto; margin-top: 0px;"><div id="OA_holder_31" class="ad-container" style="display:block"><div class="rounded overflow-hidden"><a href="https://sponsor.segmentfault.com/ck.php?oaparams=2__bannerid=322__zoneid=31__cb=d1faae0486__oadest=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000020336555" target="_blank"><img src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/86a060293605188fd8ff27a17ec0750e.png" width="300" height="100" alt="segmentfault_sudo" title="segmentfault_sudo" border="0"></a><div id="beacon_d1faae0486" style="position: absolute; left: 0px; top: 0px; visibility: hidden;"><img src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/lg(8).php" width="0" height="0" alt="" style="width: 0px; height: 0px;"></div></div>
</div></div><div id="cataLog" class="d-none d-xl-block w-xl-300 mt-4" style="top: auto;"><div data-article-nav="true" class="accordion"><div class="border-0 overflow-hidden d-none d-xl-flex card"><div class="card-body"><div><h6 class="nav-header h6 p-0 m-0"><i class="fas fa-play fa-rotate-undefined"></i><span> 目录</span></h6></div><div id="collapseTarget" class="collapse"><nav id="article-nav-list" class="d-flex flex-column font-size-14 ss-container" data-article-nav-list="true"><div class="ss-wrapper"><div class="ss-content"><a class="nav-link text-secondary p-0 my-1 text-truncate" scroll-href="#item-1" href="javascript:;">前言</a><a class="nav-link text-secondary p-0 my-1 text-truncate" scroll-href="#item-2" href="javascript:;">Java并发工具类的三板斧</a><a class="nav-link text-secondary p-0 my-1 text-truncate" scroll-href="#item-3" href="javascript:;">AQS核心实现</a><a class="nav-link text-secondary py-0 pr-0 my-1 text-truncate" scroll-href="#item-3-1" href="javascript:;">状态</a><a class="nav-link text-secondary py-0 pr-0 my-1 text-truncate" scroll-href="#item-3-2" href="javascript:;">队列</a><a class="nav-link text-secondary py-0 pr-0 my-1 text-truncate" scroll-href="#item-3-3" href="javascript:;">CAS操作</a><a class="nav-link text-secondary p-0 my-1 text-truncate" scroll-href="#item-4" href="javascript:;">AQS核心属性</a><a class="nav-link text-secondary p-0 my-1 text-truncate" scroll-href="#item-5" href="javascript:;">Example: FairSync in ReentrantLock</a><a class="nav-link text-secondary py-0 pr-0 my-1 text-truncate" scroll-href="#item-5-4" href="javascript:;">acquire</a><a class="nav-link text-secondary py-0 pr-0 my-1 text-truncate" scroll-href="#item-5-5" href="javascript:;">tryAcquire</a><a class="nav-link text-secondary py-0 pr-0 my-1 text-truncate" scroll-href="#item-5-6" href="javascript:;">addWaiter</a><a class="nav-link text-secondary py-0 pr-0 my-1 text-truncate" scroll-href="#item-5-7" href="javascript:;">enq</a><a class="nav-link text-secondary py-0 pr-0 my-1 text-truncate" scroll-href="#item-5-8" href="javascript:;">尾分叉</a><a class="nav-link text-secondary py-0 pr-0 my-1 text-truncate" scroll-href="#item-5-9" href="javascript:;">addWaiter总结</a><a class="nav-link text-secondary py-0 pr-0 my-1 text-truncate" scroll-href="#item-5-10" href="javascript:;">acquireQueued</a><a class="nav-link text-secondary py-0 pr-0 my-1 text-truncate" scroll-href="#item-5-11" href="javascript:;">shouldParkAfterFailedAcquire</a><a class="nav-link text-secondary py-0 pr-0 my-1 text-truncate" scroll-href="#item-5-12" href="javascript:;">parkAndCheckInterrupt</a><a class="nav-link text-secondary p-0 my-1 text-truncate" scroll-href="#item-6" href="javascript:;">总结</a></div></div><div class="ss-scroll" style="right: 0px;"></div></nav></div></div></div></div></div></div></div></div><div id="fixedTools" class="position-fixed d-none " style="right:24px;bottom:24px"><button type="button" class="btn btn-light" title="回顶部">▲</button></div></div><footer id="footer" class="bg-white py-5 font-size-14"><div class="container"><div class="row"><dl class="col-4 col-md-2"><dt class="h6">产品</dt><dd class="my-1"><a class="text-secondary" href="https://segmentfault.com/questions/hottest?utm_source=sf-footer" target="_blank" rel="noreferrer">热门问答</a></dd><dd class="my-1"><a class="text-secondary" href="https://segmentfault.com/blogs/hottest?utm_source=sf-footer" target="_blank" rel="noreferrer">热门专栏</a></dd><dd class="my-1"><a class="text-secondary" href="https://segmentfault.com/lives?utm_source=sf-footer" target="_blank" rel="noreferrer">热门课程</a></dd><dd class="my-1"><a class="text-secondary" href="https://segmentfault.com/events?utm_source=sf-footer" target="_blank" rel="noreferrer">最新活动</a></dd><dd class="my-1"><a class="text-secondary" href="https://segmentfault.com/groups?utm_source=sf-footer" target="_blank" rel="noreferrer">技术圈</a></dd><dd class="my-1"><a class="text-secondary" href="https://segmentfault.com/groups?tab=jobs&amp;utm_source=sf-footer" target="_blank" rel="noreferrer">酷工作</a></dd><dd class="my-1"><a class="text-secondary" href="https://segmentfault.com/app?utm_source=sf-footer" target="_blank" rel="noreferrer">移动客户端</a></dd></dl><dl class="col-4 col-md-2"><dt class="h6">课程</dt><dd class="my-1"><a class="text-secondary" href="https://segmentfault.com/lives/edu?tag=java&amp;sort=hottest&amp;utm_source=sf-footer" target="_blank" rel="noreferrer">Java 开发课程</a></dd><dd class="my-1"><a class="text-secondary" href="https://segmentfault.com/lives/edu?tag=php&amp;sort=hottest&amp;utm_source=sf-footer" target="_blank" rel="noreferrer">PHP 开发课程</a></dd><dd class="my-1"><a class="text-secondary" href="https://segmentfault.com/lives/edu?tag=python&amp;sort=hottest&amp;utm_source=sf-footer" target="_blank" rel="noreferrer">Python 开发课程</a></dd><dd class="my-1"><a class="text-secondary" href="https://segmentfault.com/lives/edu?category=1&amp;sort=hottest&amp;utm_source=sf-footer" target="_blank" rel="noreferrer">前端开发课程</a></dd><dd class="my-1"><a class="text-secondary" href="https://segmentfault.com/lives/study?category=3&amp;sort=hottest&amp;utm_source=sf-footer" target="_blank" rel="noreferrer">移动开发课程</a></dd></dl><dl class="col-4 col-md-2 "><dt class="h6">资源</dt><dd class="my-1"><a class="text-secondary" href="https://segmentfault.com/weekly?utm_source=sf-footer" target="_blank" rel="noreferrer">每周精选</a></dd><dd class="my-1"><a class="text-secondary" href="https://segmentfault.com/users?utm_source=sf-footer" target="_blank" rel="noreferrer">用户排行榜</a></dd><dd class="my-1"><a class="text-secondary" href="https://segmentfault.com/badges?utm_source=sf-footer" target="_blank" rel="noreferrer">徽章</a></dd><dd class="my-1"><a class="text-secondary" href="https://segmentfault.com/faq?utm_source=sf-footer" target="_blank" rel="noreferrer">帮助中心</a></dd><dd class="my-1"><a class="text-secondary" href="https://segmentfault.com/repu?utm_source=sf-footer" target="_blank" rel="noreferrer">声望与权限</a></dd><dd class="my-1"><a class="text-secondary" href="https://segmentfault.com/community?utm_source=sf-footer" target="_blank" rel="noreferrer">社区服务中心</a></dd></dl><dl class="col-4 col-md-2"><dt class="h6">合作</dt><dd class="my-1"><a class="text-secondary" href="https://about.segmentfault.com/?utm_source=sf-footer" target="_blank" rel="noreferrer">关于我们</a></dd><dd class="my-1"><a class="text-secondary" href="https://business.segmentfault.com/ads?utm_source=sf-footer" target="_blank" rel="noreferrer">广告投放</a></dd><dd class="my-1"><a class="text-secondary" href="https://segmentfault.com/groups?tab=jobs&amp;utm_source=sf-footer" target="_blank" rel="noreferrer">职位发布</a></dd><dd class="my-1"><a class="text-secondary" href="https://jinshuju.net/f/HK5r9K?utm_source=sf-footer" target="_blank" rel="noreferrer">讲师招募</a></dd><dd class="my-1"><a class="text-secondary" href="https://about.segmentfault.com/contact.html?utm_source=sf-footer" target="_blank" rel="noreferrer">联系我们</a></dd><dd class="my-1"><a class="text-secondary" href="https://segmentfault.com/link?utm_source=sf-footer" target="_blank" rel="noreferrer">合作伙伴</a></dd></dl><dl class="col-4 col-md-2"><dt class="h6">关注</dt><dd class="my-1"><a class="text-secondary" href="https://segmentfault.com/blog/segmentfault?utm_source=sf-footer" target="_blank" rel="noreferrer">产品技术日志</a></dd><dd class="my-1"><a class="text-secondary" href="https://segmentfault.com/blog/community_admin?utm_source=sf-footer" target="_blank" rel="noreferrer">社区运营日志</a></dd><dd class="my-1"><a class="text-secondary" href="https://segmentfault.com/blog/segmentfault_news?utm_source=sf-footer" target="_blank" rel="noreferrer">市场运营日志</a></dd><dd class="my-1"><a class="text-secondary" href="https://segmentfault.com/blog/segmentfault_team?utm_source=sf-footer" target="_blank" rel="noreferrer">团队日志</a></dd><dd class="my-1"><a class="text-secondary" href="https://segmentfault.com/blog/interview?utm_source=sf-footer" target="_blank" rel="noreferrer">社区访谈</a></dd></dl><dl class="col-4 col-md-2" id="license"><dt class="h6">条款</dt><dd class="my-1"><a class="text-secondary" href="https://segmentfault.com/tos?utm_source=sf-footer" target="_blank" rel="noreferrer">服务条款</a></dd><dd class="my-1"><a class="text-secondary" href="https://segmentfault.com/privacy?utm_source=sf-footer" target="_blank" rel="noreferrer">隐私政策</a></dd><dd class="my-1"><a class="text-secondary" href="https://segmentfault.com/app?utm_source=sf-footer">下载 App</a></dd><dd class="my-1"><div class="weixin-qrcode ml-n1" title="微信公众号"></div></dd></dl></div><hr class="mt-2 mb-4"><div class="row"><div class="col-md-8"><div class="text-secondary"><p class="mb-1">Copyright © 2011-<!-- -->2021<!-- --> SegmentFault. 当前呈现版本 <!-- -->21.02.22</p><p class="mb-1"><a class="text-secondary mr-2" target="_blank" href="http://beian.miit.gov.cn/" rel="nofollow noreferrer">浙ICP备15005796号-2</a><a class="text-secondary mr-2" target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=33010602002000" rel="nofollow noreferrer">浙公网安备33010602002000号</a><span class="text-secondary">ICP 经营许可 浙B2-20201554</span></p><p class="mb-0">杭州堆栈科技有限公司版权所有</p></div></div><div class="col-md-4 text-right"><div class="shareContent"><a class="share_weixin" data-share="weixin" href="https://segmentfault.com/a/1190000015739343#javascript" aria-label="微信"><i class="mr-1 fab fa-weixin"></i></a><a class="share_weibo" data-share="weibo" href="http://weibo.com/segmentfault" target="_blank" rel="noreferrer" aria-label="微博"><i class="fab fa-weibo mr-1"></i></a><a class="share_github" data-share="github" href="https://github.com/SegmentFault" target="_blank" rel="noreferrer" aria-label="github"><i class="mr-1 fab fa-github"></i></a><a class="share_twitter" data-share="twitter" href="https://twitter.com/segment_fault" target="_blank" rel="noreferrer" aria-label="twitter"><i class="mr-1 fab fa-twitter"></i></a></div></div></div></div></footer></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {"router":{"location":{"pathname":"\u002Fa\u002F1190000015739343","search":"","hash":"","query":{},"state":undefined,"key":"4k7myd"},"action":"POP"},"@@dva":0,"action":{"votes":48,"bookmarks":19,"votesState":false,"bookmarkState":false},"article":{"articles":{"rows":[],"size":0,"offset":0,"hasMore":true,"error":false,"loading":false,"isStopLoad":false,"cutLoadNum":1,"isLoadedFirstRecommend":false,"query":""},"currentTab":""},"articleDetail":{"artDetail":{"1190000015739343":{"title":"java - 逐行分析AQS源码(1)——独占锁的获取_个人文章","keywords":"java,java并发","description":"AQS（AbstractQueuedSynchronizer）是JAVA中众多锁以及并发工具的基础，其底层采用乐观锁，大量使用了CAS操作， 并且在冲突时，采用自旋方式重试，以实现轻量级和高效地获取锁。","article":{"id":1190000015739343,"title":"逐行分析AQS源码(1)——独占锁的获取","cover":null,"tags_list":"1040000000089449,1040000002962633","user_id":1030000015129659,"blog_id":1200000015684647,"excerpt":"AQS（AbstractQueuedSynchronizer）是JAVA中众多锁以及并发工具的基础，其底层采用乐观锁，大量使用了CAS操作， 并且在冲突时，采用自旋方式重试，以实现轻量级和高效地获取锁。","parsed_text":"","is_bookmarked":false,"is_liked":false,"created":1532354273,"modified":1537284605,"real_views":10165,"real_unique_views":9829,"votes":48,"bookmarks":19,"status":0,"origin_url":"","article_type":1,"license":"1","tags":[{"id":1040000000089449,"url":"\u002Ft\u002Fjava","name":"java","icon_url":"https:\u002F\u002Favatar-static.segmentfault.com\u002F868\u002F271\u002F868271510-54cb382abb7a1_small"},{"id":1040000002962633,"url":"\u002Ft\u002Fjava%E5%B9%B6%E5%8F%91","name":"java并发","icon_url":""}],"user":{"id":1030000015129659,"name":"ChiuCheng","avatar_url":null,"url":"\u002Fu\u002Fchiucheng","rank":885,"rankWord":"885","is_followed":false,"excerpt":"\u003Cp\u003ETalk is cheap, show me the code！\u003C\u002Fp\u003E","followers":170,"articles":26,"user_auth":null},"status_key":"available"},"blog":{"id":1200000015684647,"name":"Keep Coding","url":"\u002Fblog\u002Fchiucheng","is_followed":false,"excerpt":"记录与分享","followers":180,"articles":26,"license":"cc"},"actions":[],"member_actions":[],"article_types":{"1":"原创","2":"转载","3":"翻译"},"extra":{"reason":null,"operator":null,"operator_time":null},"tag":{"name":"java","url":"\u002Ft\u002Fjava","icon_url":"https:\u002F\u002Favatar-static.segmentfault.com\u002F868\u002F271\u002F868271510-54cb382abb7a1_small"},"isServerLoaded":true}},"alertMsg":{"showAlert":false,"msg":""},"articleRelated":[]},"editor":{"markdownContent":"","syncMarkdown":false,"title":{"value":"","isInvalid":false,"errorMsg":""},"log":{"value":"","isInvalid":false,"errorMsg":""},"draftInfo":{"id":"","status":""}},"global":{"sessionUser":null,"isHiddenHeader":false,"isHiddenFooter":false,"title":"逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否","selectedTags":[],"isShowLogin":false,"beginnerGuideState":{"visible":false,"type":1},"isShowBindMobile":false,"unactivated":false,"isShowRegister":false,"headOptions":{"keywords":"java,java并发","description":"AQS（AbstractQueuedSynchronizer）是JAVA中众多锁以及并发工具的基础，其底层采用乐观锁，大量使用了CAS操作， 并且在冲突时，采用自旋方式重试，以实现轻量级和高效地获取锁。"},"notices":[],"sessionInfo":{"key":"113ec53975bba9681263a6afa22be727","login":false,"id":null},"singleNotice":"","currentRoute":{"exact":true,"path":"\u002Fa\u002F:aid","component":{"render":function(e,t){i();var o=Object(s["useContext"])(A),a=Object(l["useSubscription"])(r);return Object(s["useImperativeHandle"])(t,(function(){return{retry:r.retry}})),o&&Array.isArray(n.modules)&&n.modules.forEach((function(e){o(e)})),a.loading||a.error?Object(s["createElement"])(n.loading,{isLoading:a.loading,pastDelay:a.pastDelay,timedOut:a.timedOut,error:a.error,retry:r.retry}):a.loaded?n.render(a.loaded,e):null},"preload":function(){return i()},"displayName":"LoadableComponent"},"_chunkName":"p__ArticleDetail"},"letterNum":0,"noticeNum":0,"serverData":{"userAgent":"Mozilla\u002F5.0 (Windows NT 10.0; Win64; x64) AppleWebKit\u002F537.36 (KHTML, like Gecko) Chrome\u002F88.0.4324.182 Safari\u002F537.36 Edg\u002F88.0.705.74","Token":undefined}},"video":{"videoData":{},"relationVideos":[],"videos":{"rows":[],"limit":0,"offset":0,"hasMore":true},"lives":[]},"home":{"channels":{},"articles":{"rows":[],"size":0,"offset":0,"hasMore":true,"error":false,"loading":false,"isStopLoad":false,"cutLoadNum":1,"isLoadedFirstRecommend":false},"currentTab":"recommendation","notices":{},"events":{},"recommendArticles":{},"hotQuestions":{},"banners":{}},"letterDetail":{"letterData":{"rows":[],"page":1,"size":100,"total_page":0,"hasMore":true},"loading":false,"readAll":false},"inbox":{"list":{"page":1,"count":0,"rows":{"inbox":{},"messages":[]},"total_page":1},"loading":false},"noticeDetail":{"noticeData":{"rows":[],"offset":"","hasMore":true},"loading":false,"readAll":false},"question":{"questionDetail":{},"relateDetail":{}},"loading":{"global":false,"models":{"global":false,"articleDetail":false},"effects":{"global\u002FgetSessionInfo":false,"articleDetail\u002FgetArtDetail":false}}};
	</script>

    <script src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/gt.js.下载"></script>
    <script>
      (function () {
        var data = window.g_initialProps["gtagData"] || window["gtagData"];
        var script = document.createElement("script");
        script.src = "https://www.googletagmanager.com/gtag/js?id=UA-918487-8";
        script.async = true;
        script.onload = function () {
          window.dataLayer = window.dataLayer || [];
          window.gtag = function () {
            window.dataLayer.push(arguments);
          };
          window.gtag("js", new Date());
          window.gtag("config", "UA-918487-8");
          data && window.gtag("set", data);
        };
        document.getElementsByTagName("head")[0].appendChild(script);
      })();
    </script>
    <script src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/umi.js.下载"></script>
  


  <div class="is-active ImageView p-4" style="display: none;">
      <div class="ImageView-inner" style="overflow: auto;">
          <img src="https://segmentfault.com/a/1190000015739343" class="ImageView-img" alt="preview" style="max-width: 100%">
      </div>
  </div><ins class="adsbygoogle adsbygoogle-noablate" data-adsbygoogle-status="done" style="display: none !important;"><ins id="aswift_1_expand" style="display:inline-table;border:none;height:0px;margin:0;padding:0;position:relative;visibility:visible;width:0px;background-color:transparent;" tabindex="0" title="Advertisement" aria-label="Advertisement"><ins id="aswift_1_anchor" style="display:block;border:none;height:0px;margin:0;padding:0;position:relative;visibility:visible;width:0px;background-color:transparent;"><iframe id="aswift_1" name="aswift_1" style="left:0;position:absolute;top:0;border:0;width:undefinedpx;height:undefinedpx;" sandbox="allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" frameborder="0" src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/ads(1).html" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" data-google-container-id="a!2" data-load-complete="true"></iframe></ins></ins></ins><iframe id="google_osd_static_frame_7455005221791" name="google_osd_static_frame" style="display: none; width: 0px; height: 0px;" src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/saved_resource(1).html"></iframe></body><iframe id="google_esf" name="google_esf" src="./逐行分析AQS源码(1)——独占锁的获取 - SegmentFault 思否_files/zrt_lookup.html" data-ad-client="ca-pub-6330872677300335" style="display: none;"></iframe></html>