

# 并查集

并查集题型关键信息：

1. 结果是**“连通块”**，**“集合”**，**“完全遍历**”等与**过程无关**的操作
2. **”交换“**，**”相连“**等**”无向边“**操作，且每个节点最终**只属于一个分区**。

## 并查集模板

### 解题步骤：

1. 搞清连通的对象
2. 通过题目给定的“交换”计算最后“连通”块的答案

```java
public int solve(String input) {
   	    int n = edges.length;
        // 下标无所谓
     	// UnionFind.java
        UnionFind unionFind = new UnionFind(n + 1);
        for (int[] edge : edges) {
            int e1 = edge[0];
            int e2 = edge[1];
            if (！unionFind.union(e1, e2)) {
                return edge;
            }
        }
        return new int[]{};
}
```
### Tips：

1. 连通对象可以是下标，分组，点坐标。一般来说，根据唯一性能写出最优的代码。
2. 是否需要预置连通块，取决于题目，如No803
3. 如果需要连通的过程或者顺序，改用搜索算法（BFS DFS 拓扑排序）

## 并查集的优化

1. 题目转化题：并查集使用后，利用图论的知识来求解，见No947，No1319。无向图请用DFS或BFS
2. 思路转话题： 并查集一般用来**合并**连通分量，而不是**拆分**连通分量（换句话说，在并查集里面，拆分连通分量是一个复杂的操作） ，当需要拆分时，考虑逆向思维，见No803

## 并查集练习题

按照难度依次排列如下：

**1、No684冗余连接：**

模板题

**2、No1202交换字符串中的元素**

模板题，通过分组求解

**3、No1319连通网络的操作次数**

模板题，结合图论及连通块数量求解，是经典题型。

**4、No947移除最多的同行或同列石头**

图论题，N个点连成的连通图，一定可以移除N-1个点后，只剩一个孤立的点。额外的，该题下标可以当成并查集的下标，而非点的坐标来表示。

**5、No959由斜杠划分区域**

题目转换题，如何将一张图切分成4个连通分量是问题的核心

**6、No1579保证图可完全遍历**

并查集进阶题，区分多个连通分量，明白题意后并不难

**7、No765情侣牵手**

如何转化成并查集问题是解题的核心，比较难想，我们按照错误情况去反向考虑就能得出答案

**8、No803打砖块**

非常难，逆向思维，预置最大的连通块，按秩合并的合理性，我愿称之为最难。













